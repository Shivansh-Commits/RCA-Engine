<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ApiParserTestDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ApiParserTestDemo.java" />
              <option name="updatedContent" value="import com.l3.logparser.api.parser.ApiParser;&#10;import com.l3.logparser.api.model.EdifactMessage;&#10;import java.util.List;&#10;&#10;/**&#10; * Simple demonstration of the refactored two-stage ApiParser&#10; */&#10;public class ApiParserTestDemo {&#10;    &#10;    public static void main(String[] args) {&#10;        ApiParser parser = new ApiParser();&#10;        &#10;        // Sample log content with EDIFACT message&#10;        String logContent = &quot;2024-11-30 10:15:23 INFO  [Thread-1] com.example.Forward.BUSINESS_RULES_PROCESSOR - Message body [UNA:+.?'UNB+IATB:1+6X+FRAORD+240725+1130+TS2302507251130'UNH+TS2302507251130+PAXLST:D:05B:UN:IATA+TS2302507251130'BGM+745+TS2302507251130'TDT+20+MS775++MS'LOC+125+FRA'LOC+87+ORD'DTM+189:24072511:30'UNZ+1+TS2302507251130']&quot;;&#10;        &#10;        // Test parsing with debug mode&#10;        List&lt;EdifactMessage&gt; messages = parser.parseLogContent(logContent, &quot;MS775&quot;, true, &#10;            debugMsg -&gt; System.out.println(&quot;[DEBUG] &quot; + debugMsg));&#10;        &#10;        System.out.println(&quot;\n=== PARSING RESULTS ===&quot;);&#10;        System.out.println(&quot;Found &quot; + messages.size() + &quot; messages&quot;);&#10;        &#10;        for (int i = 0; i &lt; messages.size(); i++) {&#10;            EdifactMessage msg = messages.get(i);&#10;            System.out.println(&quot;\nMessage &quot; + (i + 1) + &quot;:&quot;);&#10;            System.out.println(&quot;  Flight Number: &quot; + msg.getFlightNumber());&#10;            System.out.println(&quot;  Message ID: &quot; + msg.getMessageId());&#10;            System.out.println(&quot;  Data Type: &quot; + msg.getDataType());&#10;            System.out.println(&quot;  Part Number: &quot; + msg.getPartNumber());&#10;            System.out.println(&quot;  Part Indicator: &quot; + msg.getPartIndicator());&#10;            &#10;            if (msg.getFlightDetails() != null) {&#10;                System.out.println(&quot;  Flight Details:&quot;);&#10;                System.out.println(&quot;    Departure: &quot; + msg.getFlightDetails().getDepartureAirport());&#10;                System.out.println(&quot;    Arrival: &quot; + msg.getFlightDetails().getArrivalAirport());&#10;                System.out.println(&quot;    Departure Date: &quot; + msg.getFlightDetails().getDepartureDate());&#10;                System.out.println(&quot;    Departure Time: &quot; + msg.getFlightDetails().getDepartureTime());&#10;            }&#10;            &#10;            System.out.println(&quot;  Raw Content Length: &quot; + &#10;                (msg.getRawContent() != null ? msg.getRawContent().length() : 0) + &quot; chars&quot;);&#10;        }&#10;        &#10;        System.out.println(&quot;\n=== TWO-STAGE PARSING COMPLETE ===&quot;);&#10;        System.out.println(&quot;Stage 1: Extract message boundaries (start patterns to UNZ)&quot;);&#10;        System.out.println(&quot;Stage 2: Parse each message character-by-character using separators&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PROJECT_RETROSPECTIVE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PROJECT_RETROSPECTIVE.md" />
              <option name="updatedContent" value="# L3 Engine - Log Extraction Tool&#10;## Project Retrospective Brief&#10;&#10;### Project Vision &amp; Goals&#10;&#10;**What We Set Out to Build:**&#10;The L3 Engine Log Extraction Tool was conceived to address a critical operational challenge faced by our airline operations team. When flight incidents occur, our support engineers need to quickly gather and analyze relevant log files from multiple systems to perform root cause analysis and resolve issues.&#10;&#10;**The Problem We Aimed to Solve:**&#10;- **Manual Log Collection**: Engineers were spending hours manually collecting log files from various systems across different servers&#10;- **Time-Critical Analysis**: Flight incidents require rapid response, but log collection was becoming a bottleneck&#10;- **Scattered Data Sources**: Log files were distributed across multiple systems (DAS, MessageTypeB, MessageAPI, MessageForwarder)&#10;- **Inconsistent Process**: Different engineers had different approaches to log collection, leading to missed files or incomplete data sets&#10;&#10;### Technical Architecture Decision&#10;&#10;**Core Design Philosophy:**&#10;We designed the tool around a **pipeline-driven artifact collection** model, leveraging Azure DevOps pipelines to orchestrate log gathering from remote systems, then automatically downloading and organizing the results.&#10;&#10;**Key Components:**&#10;1. **Azure Pipeline Integration**: Trigger remote log collection processes via Azure DevOps API&#10;2. **Artifact Management**: Download and extract build artifacts containing collected logs&#10;3. **JavaFX Desktop Application**: Provide an intuitive interface for operations teams&#10;4. **Message Extraction Engine**: Parse and analyze collected logs for specific flight data&#10;&#10;### Expected Benefits&#10;&#10;**Operational Efficiency:**&#10;- Reduce log collection time from hours to minutes&#10;- Standardize the log collection process across all engineers&#10;- Enable faster incident response and resolution&#10;&#10;**Data Completeness:**&#10;- Ensure all relevant log sources are consistently collected&#10;- Reduce risk of missing critical log files during incident analysis&#10;- Provide comprehensive artifact organization and preview capabilities&#10;&#10;**Team Productivity:**&#10;- Free up engineering time from manual log gathering tasks&#10;- Enable focus on actual analysis and problem-solving&#10;- Provide self-service capabilities for operations teams&#10;&#10;### Implementation Approach&#10;&#10;**Phase 1: Core Infrastructure**&#10;- Azure DevOps pipeline integration for triggering remote log collection&#10;- Build artifact download and extraction capabilities&#10;- Basic desktop application framework with JavaFX&#10;&#10;**Phase 2: Enhanced Features**&#10;- Real-time pipeline status monitoring&#10;- File preview and organization capabilities&#10;- Configuration management for different environments&#10;&#10;**Phase 3: Analysis Integration**&#10;- Message parsing and extraction from collected logs&#10;- Root cause analysis reporting features&#10;- Integration with existing operational workflows&#10;&#10;### Success Metrics&#10;&#10;**Performance Targets:**&#10;- Reduce log collection time by 80% (from 2-4 hours to 15-30 minutes)&#10;- Achieve 99%+ collection reliability across all target log sources&#10;- Support parallel processing of multiple flight incidents&#10;&#10;**Quality Indicators:**&#10;- Zero missed log files during collection process&#10;- Standardized file organization and naming conventions&#10;- Comprehensive audit trail of collection activities&#10;&#10;### Risk Mitigation Strategies&#10;&#10;**Technical Risks:**&#10;- **Azure DevOps Dependency**: Implemented robust error handling and retry mechanisms&#10;- **Network Connectivity**: Added offline preview capabilities and local caching&#10;- **Authentication Issues**: Comprehensive token validation and detailed error messaging&#10;&#10;**Operational Risks:**&#10;- **User Training**: Designed intuitive interface requiring minimal training&#10;- **Process Changes**: Maintained backward compatibility with existing workflows&#10;- **System Integration**: Flexible configuration system for different environments&#10;&#10;---&#10;&#10;*This retrospective represents the project vision and planning that guided the development of the L3 Engine Log Extraction Tool. The tool successfully addresses critical operational needs by automating and standardizing the log collection process for flight incident analysis.*" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/error_codes_appendix.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/error_codes_appendix.md" />
              <option name="updatedContent" value="---&#10;&#10;## Appendix B: Error Codes Reference&#10;&#10;L3 Engine uses standardized error codes to help you quickly identify and resolve issues. Each error includes a specific code, description, and resolution steps.&#10;&#10;### B.1 Log Extraction Engine Errors (LE001-LE005)&#10;&#10;| Error Code | Description | What It Means | How to Fix |&#10;|------------|-------------|---------------|------------|&#10;| **LE001** | Azure configuration missing | Azure DevOps connection is not configured | Click the ⚙ Configure Azure button and enter your organization URL, project name, and Personal Access Token |&#10;| **LE002** | Invalid credentials | Your Personal Access Token is incorrect or expired | 1. Check your token is copied correctly&lt;br&gt;2. Generate a new token at Azure DevOps&lt;br&gt;3. Ensure token has Build and Release permissions |&#10;| **LE003** | Pipeline trigger failed | The extraction pipeline failed to start or execute | 1. Verify the flight operated on the specified date&lt;br&gt;2. Check Azure DevOps is accessible&lt;br&gt;3. Wait a few minutes and try again |&#10;| **LE004** | Network connectivity error | Cannot connect to Azure DevOps | 1. Check your internet connection&lt;br&gt;2. Verify Azure DevOps URL is correct&lt;br&gt;3. Contact IT if firewall may be blocking access |&#10;| **LE005** | Insufficient permissions | Your account lacks necessary Azure DevOps permissions | Contact your Azure DevOps administrator to grant Build and Release permissions |&#10;&#10;### B.2 Log Parser Engine Errors (LP001-LP005)&#10;&#10;| Error Code | Description | What It Means | How to Fix |&#10;|------------|-------------|---------------|------------|&#10;| **LP001** | Invalid directory path | The selected log directory is invalid or inaccessible | 1. Ensure the directory exists&lt;br&gt;2. Check you have read permissions&lt;br&gt;3. Select a different directory |&#10;| **LP002** | No EDIFACT messages found | No passenger data found in the log files | 1. Verify logs contain passenger data&lt;br&gt;2. Check flight number and date accuracy&lt;br&gt;3. Try different data type (API ↔ PNR) |&#10;| **LP003** | Message parsing failed | Error processing passenger message format | 1. Verify flight number format (minimum 3 characters)&lt;br&gt;2. Ensure departure date is selected&lt;br&gt;3. Contact development team if issue persists |&#10;| **LP004** | Multi-node consolidation error | Failed to combine logs from multiple nodes | 1. Check n1/, n2/, n3/ subdirectories exist&lt;br&gt;2. Disable multi-node mode if not needed&lt;br&gt;3. Ensure subdirectories contain log files |&#10;| **LP005** | File format not supported | The log file format cannot be processed | 1. Verify you're using standard application log files&lt;br&gt;2. Check files aren't corrupted&lt;br&gt;3. Contact support for format assistance |&#10;&#10;### B.3 RCA Engine Errors (RCA001-RCA005)&#10;&#10;| Error Code | Description | What It Means | How to Fix |&#10;|------------|-------------|---------------|------------|&#10;| **RCA001** | No passenger files found | No data files available for analysis | 1. Select a folder containing input/ and output/ subdirectories&lt;br&gt;2. Process logs through Log Parser Engine first&lt;br&gt;3. Verify folder contains passenger data files |&#10;| **RCA002** | File parsing error | Error reading or processing passenger data files | 1. Ensure files weren't manually modified&lt;br&gt;2. Verify file format is correct&lt;br&gt;3. Try processing smaller data sets |&#10;| **RCA003** | Data validation failed | Passenger records contain invalid or missing information | 1. Check source data quality&lt;br&gt;2. Review warnings list for specific issues&lt;br&gt;3. Fix data at source if possible |&#10;| **RCA004** | Excel export failed | Cannot generate or save the analysis report | 1. Check available disk space&lt;br&gt;2. Ensure output directory is writable&lt;br&gt;3. Close Excel if it's open and try again |&#10;| **RCA005** | Memory allocation error | Insufficient memory to process the dataset | 1. Close other applications&lt;br&gt;2. Process smaller data sets&lt;br&gt;3. Consider increasing system memory |&#10;&#10;### B.4 Flight Number Validation Rules&#10;&#10;**Valid Flight Number Formats:**&#10;- Minimum 3 characters, maximum 8 characters&#10;- Can contain letters, numbers, and the + symbol&#10;- Examples: `WF123`, `AI101`, `6E2024`, `SG+8475`&#10;&#10;**Important Notes:**&#10;- **Log Extractor**: Accepts + symbol between carrier code and flight number (e.g., `SG+8475`)&#10;- **Log Parser/RCA Engine**: Flight numbers should follow standard airline format&#10;- Not case-sensitive (`wf123` works same as `WF123`)&#10;&#10;### B.5 Troubleshooting Quick Reference&#10;&#10;**Most Common Issues:**&#10;&#10;1. **&quot;Azure configuration missing&quot; (LE001)**&#10;   - **Solution**: Click ⚙ Configure Azure → Enter organization, project, token → Save&#10;&#10;2. **&quot;No EDIFACT messages found&quot; (LP002)**&#10;   - **Solution**: Try switching data type (API ↔ PNR) → Verify flight number/date&#10;&#10;3. **&quot;No passenger files found&quot; (RCA001)**&#10;   - **Solution**: Use Log Parser Engine first → Select correct folder structure&#10;&#10;4. **&quot;Pipeline trigger failed&quot; (LE003)**&#10;   - **Solution**: Check flight date accuracy → Verify Azure connection → Retry&#10;&#10;5. **&quot;Multi-node consolidation error&quot; (LP004)**&#10;   - **Solution**: Turn OFF multi-node mode → Or ensure n1/, n2/, n3/ folders exist&#10;&#10;### B.6 Getting Additional Help&#10;&#10;If you encounter errors not covered in this guide:&#10;&#10;1. **Check the application log area** - Look for detailed error messages&#10;2. **Try the suggested resolution steps** - Follow the specific guidance for your error code&#10;3. **Contact your team lead** - For Azure DevOps access or configuration issues&#10;4. **Contact development team** - For persistent technical issues or unknown error codes&#10;&#10;**When reporting issues, include:**&#10;- The exact error code (e.g., LE003, LP002)&#10;- What you were trying to do when the error occurred&#10;- Flight number and date you were investigating&#10;- Any additional error messages from the application log area&#10;&#10;---&#10;&#10;**Document Version:** 3.2.0.0  &#10;**Last Updated:** November 25, 2024  &#10;**Contact:** L3 Engine Development Team" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom_fixed.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom_fixed.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.l3&lt;/groupId&gt;&#10;    &lt;artifactId&gt;engine&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;    &lt;name&gt;L3 Engine&lt;/name&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;junit.version&gt;5.10.2&lt;/junit.version&gt;&#10;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;&#10;        &lt;javafx.version&gt;21&lt;/javafx.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;&#10;            &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;&#10;            &lt;version&gt;21&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;&#10;            &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;&#10;            &lt;version&gt;21&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Apache POI for Excel generation --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;5.2.5&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;5.2.5&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Log4j2 core implementation to fix logging warning --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;&#10;            &lt;version&gt;2.21.1&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${junit.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;&#10;            &lt;version&gt;${junit.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.testng&lt;/groupId&gt;&#10;            &lt;artifactId&gt;testng&lt;/artifactId&gt;&#10;            &lt;version&gt;7.5&lt;/version&gt;&#10;            &lt;scope&gt;compile&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.13.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;21&lt;/source&gt;&#10;                    &lt;target&gt;21&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &#10;            &lt;!-- Maven Shade Plugin for creating executable JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.5.1&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;transformers&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&#10;                                    &lt;mainClass&gt;com.l3.apipnrengine.controller.MainApp&lt;/mainClass&gt;&#10;                                &lt;/transformer&gt;&#10;                            &lt;/transformers&gt;&#10;                            &lt;filters&gt;&#10;                                &lt;filter&gt;&#10;                                    &lt;artifact&gt;*:*&lt;/artifact&gt;&#10;                                    &lt;excludes&gt;&#10;                                        &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;&#10;                                        &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;&#10;                                        &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;&#10;                                    &lt;/excludes&gt;&#10;                                &lt;/filter&gt;&#10;                            &lt;/filters&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;            &#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.openjfx&lt;/groupId&gt;&#10;                &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;0.0.8&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;!-- Default configuration for running with: mvn clean javafx:run --&gt;&#10;                        &lt;id&gt;default-cli&lt;/id&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;mainClass&gt;com.l3.apipnrengine.controller.MainApp&lt;/mainClass&gt;&#10;                            &lt;launcher&gt;app&lt;/launcher&gt;&#10;                            &lt;jlinkZipName&gt;app&lt;/jlinkZipName&gt;&#10;                            &lt;jlinkImageName&gt;app&lt;/jlinkImageName&gt;&#10;                            &lt;noManPages&gt;true&lt;/noManPages&gt;&#10;                            &lt;stripDebug&gt;true&lt;/stripDebug&gt;&#10;                            &lt;noHeaderFiles&gt;true&lt;/noHeaderFiles&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logextractor/service/FileDownloadService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logextractor/service/FileDownloadService.java" />
              <option name="originalContent" value="package com.l3.logextractor.service;&#10;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.l3.logextractor.config.AzureConfig;&#10;import com.l3.logextractor.model.ArtifactInfo;&#10;import org.apache.hc.client5.http.classic.methods.HttpGet;&#10;import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;&#10;import org.apache.hc.client5.http.impl.classic.HttpClients;&#10;import org.apache.hc.core5.http.ClassicHttpResponse;&#10;import org.apache.hc.core5.http.HttpEntity;&#10;import org.apache.hc.core5.http.io.entity.EntityUtils;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.nio.file.StandardCopyOption;&#10;import java.util.ArrayList;&#10;import java.util.Base64;&#10;import java.util.List;&#10;import java.util.function.Consumer;&#10;import java.util.zip.ZipEntry;&#10;import java.util.zip.ZipInputStream;&#10;import java.util.zip.GZIPInputStream;&#10;&#10;/**&#10; * Service class for downloading and managing build artifacts from Azure DevOps&#10; */&#10;public class FileDownloadService {&#10;&#10;    private final AzureConfig config;&#10;    private final ObjectMapper objectMapper;&#10;    private final CloseableHttpClient httpClient;&#10;&#10;    public FileDownloadService(AzureConfig config) {&#10;        this.config = config;&#10;        this.objectMapper = new ObjectMapper();&#10;        this.httpClient = HttpClients.createDefault();&#10;    }&#10;&#10;    /**&#10;     * Get list of available artifacts for a build&#10;     */&#10;    public List&lt;ArtifactInfo&gt; getArtifacts(String buildId, Consumer&lt;String&gt; logCallback) {&#10;        List&lt;ArtifactInfo&gt; artifacts = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            String artifactsUrl = String.format(&quot;%s/%s/%s/_apis/build/builds/%s/artifacts?api-version=7.0&quot;,&#10;                config.getBaseUrl(), config.getOrganization(), config.getProject(), buildId);&#10;&#10;            HttpGet getRequest = new HttpGet(artifactsUrl);&#10;            getRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;            ClassicHttpResponse response = httpClient.execute(getRequest);&#10;            HttpEntity entity = response.getEntity();&#10;            String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);&#10;&#10;            if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;                JsonNode jsonResponse = objectMapper.readTree(responseBody);&#10;                JsonNode artifactsArray = jsonResponse.get(&quot;value&quot;);&#10;&#10;                if (artifactsArray != null &amp;&amp; artifactsArray.isArray()) {&#10;                    for (JsonNode artifactNode : artifactsArray) {&#10;                        ArtifactInfo artifact = new ArtifactInfo();&#10;                        artifact.setName(artifactNode.get(&quot;name&quot;).asText());&#10;                        artifact.setId(artifactNode.get(&quot;id&quot;).asText());&#10;&#10;                        JsonNode resourceNode = artifactNode.get(&quot;resource&quot;);&#10;                        if (resourceNode != null) {&#10;                            artifact.setDownloadUrl(resourceNode.get(&quot;downloadUrl&quot;).asText());&#10;                            if (resourceNode.has(&quot;properties&quot;)) {&#10;                                JsonNode propsNode = resourceNode.get(&quot;properties&quot;);&#10;                                if (propsNode.has(&quot;artifactsize&quot;)) {&#10;                                    artifact.setSize(propsNode.get(&quot;artifactsize&quot;).asLong());&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        artifacts.add(artifact);&#10;                        logCallback.accept(&quot;Found artifact: &quot; + artifact.getName());&#10;                    }&#10;                }&#10;            } else {&#10;                logCallback.accept(&quot;Failed to retrieve artifacts. Status: &quot; + response.getCode());&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error retrieving artifacts: &quot; + e.getMessage());&#10;        }&#10;&#10;        return artifacts;&#10;    }&#10;&#10;    /**&#10;     * Download an artifact to the specified directory&#10;     */&#10;    public boolean downloadArtifact(ArtifactInfo artifact, String outputDir, Consumer&lt;String&gt; logCallback) {&#10;        try {&#10;            logCallback.accept(&quot;Starting download of: &quot; + artifact.getName());&#10;&#10;            HttpGet downloadRequest = new HttpGet(artifact.getDownloadUrl());&#10;            downloadRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;            ClassicHttpResponse response = httpClient.execute(downloadRequest);&#10;&#10;            if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;                HttpEntity entity = response.getEntity();&#10;&#10;                // Create output directory if it doesn't exist&#10;                Path outputPath = Paths.get(outputDir);&#10;                Files.createDirectories(outputPath);&#10;&#10;                // Download and extract zip file&#10;                try (InputStream inputStream = entity.getContent()) {&#10;                    if (artifact.getName().toLowerCase().endsWith(&quot;.zip&quot;) ||&#10;                        artifact.getDownloadUrl().contains(&quot;format=zip&quot;)) {&#10;                        extractZipFile(inputStream, outputPath, artifact.getName(), logCallback);&#10;                    } else {&#10;                        // Download as single file&#10;                        Path filePath = outputPath.resolve(artifact.getName());&#10;                        Files.copy(inputStream, filePath, StandardCopyOption.REPLACE_EXISTING);&#10;                        logCallback.accept(&quot;Downloaded: &quot; + artifact.getName());&#10;&#10;                        // If the downloaded file is a .gz file, extract it in place&#10;                        if (filePath.toString().toLowerCase().endsWith(&quot;.gz&quot;)) {&#10;                            extractGzipFile(filePath, logCallback);&#10;                        }&#10;                    }&#10;                }&#10;&#10;                logCallback.accept(&quot;Successfully downloaded: &quot; + artifact.getName());&#10;                return true;&#10;            } else {&#10;                logCallback.accept(&quot;Failed to download artifact. Status: &quot; + response.getCode());&#10;                return false;&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error downloading artifact: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract zip file contents to the specified directory&#10;     */&#10;    private void extractZipFile(InputStream zipInputStream, Path outputDir, String artifactName, Consumer&lt;String&gt; logCallback) {&#10;        try (ZipInputStream zis = new ZipInputStream(zipInputStream)) {&#10;            ZipEntry zipEntry;&#10;&#10;            while ((zipEntry = zis.getNextEntry()) != null) {&#10;                if (!zipEntry.isDirectory()) {&#10;                    Path filePath = outputDir.resolve(zipEntry.getName());&#10;&#10;                    // Create parent directories if they don't exist&#10;                    Files.createDirectories(filePath.getParent());&#10;&#10;                    try (FileOutputStream fos = new FileOutputStream(filePath.toFile())) {&#10;                        byte[] buffer = new byte[1024];&#10;                        int length;&#10;                        while ((length = zis.read(buffer)) &gt;= 0) {&#10;                            fos.write(buffer, 0, length);&#10;                        }&#10;                    }&#10;&#10;                    logCallback.accept(&quot;Extracted: &quot; + zipEntry.getName());&#10;&#10;                    // If the extracted file is a .gz file, extract it in place&#10;                    if (filePath.toString().toLowerCase().endsWith(&quot;.gz&quot;)) {&#10;                        extractGzipFile(filePath, logCallback);&#10;                    }&#10;                }&#10;                zis.closeEntry();&#10;            }&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error extracting zip file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract a .gz file in place and remove the .gz file after extraction&#10;     */&#10;    private void extractGzipFile(Path gzipFile, Consumer&lt;String&gt; logCallback) {&#10;        try {&#10;            String originalFileName = gzipFile.getFileName().toString();&#10;            String extractedFileName = originalFileName.substring(0, originalFileName.length() - 3); // Remove .gz extension&#10;            Path extractedFile = gzipFile.getParent().resolve(extractedFileName);&#10;&#10;            logCallback.accept(&quot;Extracting gzip file: &quot; + originalFileName);&#10;&#10;            // Extract the gzip file&#10;            try (FileInputStream fis = new FileInputStream(gzipFile.toFile());&#10;                 GZIPInputStream gis = new GZIPInputStream(fis);&#10;                 FileOutputStream fos = new FileOutputStream(extractedFile.toFile())) {&#10;&#10;                byte[] buffer = new byte[1024];&#10;                int length;&#10;                while ((length = gis.read(buffer)) &gt;= 0) {&#10;                    fos.write(buffer, 0, length);&#10;                }&#10;            }&#10;&#10;            // Delete the original .gz file after successful extraction&#10;            Files.delete(gzipFile);&#10;            logCallback.accept(&quot;Successfully extracted and removed .gz file: &quot; + originalFileName + &quot; -&gt; &quot; + extractedFileName);&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error extracting gzip file &quot; + gzipFile.getFileName() + &quot;: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file preview content (first few lines)&#10;     */&#10;    public String getFilePreview(String filePath, int maxLines) {&#10;        try {&#10;            List&lt;String&gt; lines = Files.readAllLines(Paths.get(filePath));&#10;            StringBuilder preview = new StringBuilder();&#10;&#10;            int linesToRead = Math.min(maxLines, lines.size());&#10;            for (int i = 0; i &lt; linesToRead; i++) {&#10;                preview.append(lines.get(i)).append(&quot;\n&quot;);&#10;            }&#10;&#10;            if (lines.size() &gt; maxLines) {&#10;                preview.append(&quot;... (&quot;).append(lines.size() - maxLines).append(&quot; more lines)&quot;);&#10;            }&#10;&#10;            return preview.toString();&#10;        } catch (Exception e) {&#10;            return &quot;Error reading file: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download all pipeline artifacts after successful completion&#10;     * This is the main orchestration method that should be called after pipeline success&#10;     */&#10;    public List&lt;Path&gt; downloadPipelineArtifacts(String buildId, String flightNumber, Consumer&lt;String&gt; logCallback) {&#10;        List&lt;Path&gt; downloadedFiles = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            logCallback.accept(&quot;Starting artifact discovery and download for build: &quot; + buildId);&#10;&#10;            // Step 1: Get list of available artifacts from Azure DevOps&#10;            List&lt;ArtifactInfo&gt; artifacts = getArtifacts(buildId, logCallback);&#10;&#10;            if (artifacts.isEmpty()) {&#10;                logCallback.accept(&quot;No artifacts found for build &quot; + buildId);&#10;                return downloadedFiles;&#10;            }&#10;&#10;            logCallback.accept(&quot;Found &quot; + artifacts.size() + &quot; artifacts to download&quot;);&#10;&#10;            // Step 2: Create download directory&#10;            String downloadDir = createDownloadDirectory(flightNumber);&#10;            logCallback.accept(&quot;Download directory: &quot; + downloadDir);&#10;&#10;            // Step 3: Download each artifact&#10;            for (ArtifactInfo artifact : artifacts) {&#10;                logCallback.accept(&quot;Downloading artifact: &quot; + artifact.getName());&#10;&#10;                boolean success = downloadArtifact(artifact, downloadDir, logCallback);&#10;&#10;                if (success) {&#10;                    // Step 4: Find and collect downloaded files&#10;                    List&lt;Path&gt; extractedFiles = findExtractedFiles(downloadDir, artifact.getName(), logCallback);&#10;                    downloadedFiles.addAll(extractedFiles);&#10;                } else {&#10;                    logCallback.accept(&quot;Failed to download artifact: &quot; + artifact.getName());&#10;                }&#10;            }&#10;&#10;            logCallback.accept(&quot;Download completed. Total files: &quot; + downloadedFiles.size());&#10;&#10;            // Step 5: Log summary of downloaded files&#10;            for (Path file : downloadedFiles) {&#10;                logCallback.accept(&quot;Downloaded file: &quot; + file.getFileName() + &quot; (&quot; + getFileSize(file) + &quot;)&quot;);&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error downloading pipeline artifacts: &quot; + e.getMessage());&#10;        }&#10;&#10;        return downloadedFiles;&#10;    }&#10;&#10;    /**&#10;     * Create a download directory for the flight&#10;     */&#10;    private String createDownloadDirectory(String flightNumber) throws IOException {&#10;        String userHome = System.getProperty(&quot;user.home&quot;);&#10;        String downloadDir = String.format(&quot;%s/Downloads/L3Engine_Logs/%s_%s&quot;,&#10;            userHome,&#10;            flightNumber,&#10;            java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd_HHmmss&quot;))&#10;        );&#10;&#10;        Path downloadPath = Paths.get(downloadDir);&#10;        Files.createDirectories(downloadPath);&#10;&#10;        return downloadDir;&#10;    }&#10;&#10;    /**&#10;     * Find all extracted files from an artifact download&#10;     */&#10;    private List&lt;Path&gt; findExtractedFiles(String downloadDir, String artifactName, Consumer&lt;String&gt; logCallback) {&#10;        List&lt;Path&gt; files = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            Path dirPath = Paths.get(downloadDir);&#10;&#10;            Files.walk(dirPath)&#10;                 .filter(Files::isRegularFile)&#10;                 .filter(path -&gt; isLogFile(path))&#10;                 .forEach(files::add);&#10;&#10;            logCallback.accept(&quot;Found &quot; + files.size() + &quot; log files in &quot; + artifactName);&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error finding extracted files: &quot; + e.getMessage());&#10;        }&#10;&#10;        return files;&#10;    }&#10;&#10;    /**&#10;     * Check if a file is a log file based on extension or name patterns&#10;     */&#10;    private boolean isLogFile(Path file) {&#10;        String fileName = file.getFileName().toString().toLowerCase();&#10;        return fileName.endsWith(&quot;.log&quot;) ||&#10;               fileName.endsWith(&quot;.txt&quot;) ||&#10;               fileName.contains(&quot;log&quot;) ||&#10;               fileName.endsWith(&quot;.csv&quot;) ||&#10;               fileName.endsWith(&quot;.json&quot;) ||&#10;               fileName.endsWith(&quot;.gz&quot;); // Include .gz files as they often contain compressed logs&#10;    }&#10;&#10;    /**&#10;     * Get formatted file size&#10;     */&#10;    private String getFileSize(Path file) {&#10;        try {&#10;            long bytes = Files.size(file);&#10;            return formatFileSize(bytes);&#10;        } catch (Exception e) {&#10;            return &quot;Unknown size&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size in human readable format&#10;     */&#10;    private String formatFileSize(long bytes) {&#10;        if (bytes &lt; 1024) return bytes + &quot; B&quot;;&#10;        int exp = (int) (Math.log(bytes) / Math.log(1024));&#10;        String pre = &quot;KMGTPE&quot;.charAt(exp - 1) + &quot;&quot;;&#10;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(1024, exp), pre);&#10;    }&#10;&#10;    private String getEncodedAuth() {&#10;        String auth = &quot;:&quot; + config.getPersonalAccessToken();&#10;        return Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));&#10;    }&#10;&#10;    public void close() throws IOException {&#10;        httpClient.close();&#10;    }&#10;&#10;    /**&#10;     * Get file names from a zip artifact without downloading the entire artifact&#10;     */&#10;    public List&lt;String&gt; getFileNamesFromArtifact(ArtifactInfo artifact) {&#10;        List&lt;String&gt; fileNames = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            HttpGet downloadRequest = new HttpGet(artifact.getDownloadUrl());&#10;            downloadRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;            ClassicHttpResponse response = httpClient.execute(downloadRequest);&#10;&#10;            if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;                HttpEntity entity = response.getEntity();&#10;&#10;                // Read the zip file and extract file names&#10;                try (InputStream inputStream = entity.getContent();&#10;                     ZipInputStream zis = new ZipInputStream(inputStream)) {&#10;&#10;                    ZipEntry zipEntry;&#10;                    while ((zipEntry = zis.getNextEntry()) != null) {&#10;                        if (!zipEntry.isDirectory()) {&#10;                            String fileName = zipEntry.getName();&#10;                            // Extract just the filename without directory path&#10;                            if (fileName.contains(&quot;/&quot;)) {&#10;                                fileName = fileName.substring(fileName.lastIndexOf(&quot;/&quot;) + 1);&#10;                            }&#10;                            if (fileName.contains(&quot;\\&quot;)) {&#10;                                fileName = fileName.substring(fileName.lastIndexOf(&quot;\\&quot;) + 1);&#10;                            }&#10;                            if (!fileName.isEmpty() &amp;&amp; isLogFile(Paths.get(fileName))) {&#10;                                fileNames.add(fileName);&#10;                            }&#10;                        }&#10;                        zis.closeEntry();&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            // If we can't read the zip, return empty list&#10;        }&#10;&#10;        return fileNames;&#10;    }&#10;&#10;    /**&#10;     * Download a specific file from an artifact&#10;     */&#10;    public boolean downloadSpecificFile(ArtifactInfo artifact, String specificFileName, String outputDir, Consumer&lt;String&gt; logCallback) {&#10;        if (specificFileName == null) {&#10;            // If no specific file requested, download the entire artifact&#10;            return downloadArtifact(artifact, outputDir, logCallback);&#10;        }&#10;&#10;        try {&#10;            logCallback.accept(&quot;Downloading specific file: &quot; + specificFileName + &quot; from artifact: &quot; + artifact.getName());&#10;&#10;            HttpGet downloadRequest = new HttpGet(artifact.getDownloadUrl());&#10;            downloadRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;            ClassicHttpResponse response = httpClient.execute(downloadRequest);&#10;&#10;            if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;                HttpEntity entity = response.getEntity();&#10;&#10;                // Create output directory if it doesn't exist&#10;                Path outputPath = Paths.get(outputDir);&#10;                Files.createDirectories(outputPath);&#10;&#10;                // Extract only the specific file from the zip&#10;                try (InputStream inputStream = entity.getContent();&#10;                     ZipInputStream zis = new ZipInputStream(inputStream)) {&#10;&#10;                    ZipEntry zipEntry;&#10;                    while ((zipEntry = zis.getNextEntry()) != null) {&#10;                        if (!zipEntry.isDirectory()) {&#10;                            String fileName = zipEntry.getName();&#10;                            // Extract just the filename without directory path&#10;                            String baseFileName = fileName;&#10;                            if (fileName.contains(&quot;/&quot;)) {&#10;                                baseFileName = fileName.substring(fileName.lastIndexOf(&quot;/&quot;) + 1);&#10;                            }&#10;                            if (fileName.contains(&quot;\\&quot;)) {&#10;                                baseFileName = fileName.substring(fileName.lastIndexOf(&quot;\\&quot;) + 1);&#10;                            }&#10;&#10;                            // Check if this is the file we're looking for&#10;                            if (baseFileName.equals(specificFileName)) {&#10;                                Path filePath = outputPath.resolve(baseFileName);&#10;&#10;                                try (FileOutputStream fos = new FileOutputStream(filePath.toFile())) {&#10;                                    byte[] buffer = new byte[1024];&#10;                                    int length;&#10;                                    while ((length = zis.read(buffer)) &gt;= 0) {&#10;                                        fos.write(buffer, 0, length);&#10;                                    }&#10;                                }&#10;&#10;                                logCallback.accept(&quot;Successfully extracted: &quot; + baseFileName);&#10;&#10;                                // If the extracted file is a .gz file, extract it in place&#10;                                if (filePath.toString().toLowerCase().endsWith(&quot;.gz&quot;)) {&#10;                                    extractGzipFile(filePath, logCallback);&#10;                                }&#10;&#10;                                zis.closeEntry();&#10;                                return true;&#10;                            }&#10;                        }&#10;                        zis.closeEntry();&#10;                    }&#10;                }&#10;&#10;                logCallback.accept(&quot;File not found in artifact: &quot; + specificFileName);&#10;                return false;&#10;            } else {&#10;                logCallback.accept(&quot;Failed to download artifact. Status: &quot; + response.getCode());&#10;                return false;&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error downloading specific file: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Class representing artifact information&#10;     */&#10;    public static class ArtifactInfo {&#10;        private String name;&#10;        private String id;&#10;        private String downloadUrl;&#10;        private long size;&#10;&#10;        // Getters and setters&#10;        public String getName() { return name; }&#10;        public void setName(String name) { this.name = name; }&#10;&#10;        public String getId() { return id; }&#10;        public void setId(String id) { this.id = id; }&#10;&#10;        public String getDownloadUrl() { return downloadUrl; }&#10;        public void setDownloadUrl(String downloadUrl) { this.downloadUrl = downloadUrl; }&#10;&#10;        public long getSize() { return size; }&#10;        public void setSize(long size) { this.size = size; }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return String.format(&quot;ArtifactInfo{name='%s', id='%s', size=%d}&quot;, name, id, size);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.l3.logextractor.service;&#10;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.l3.logextractor.config.AzureConfig;&#10;import com.l3.logextractor.model.ArtifactInfo;&#10;import org.apache.hc.client5.http.classic.methods.HttpGet;&#10;import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;&#10;import org.apache.hc.client5.http.impl.classic.HttpClients;&#10;import org.apache.hc.client5.http.config.RequestConfig;&#10;import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;&#10;import org.apache.hc.core5.http.ClassicHttpResponse;&#10;import org.apache.hc.core5.http.HttpEntity;&#10;import org.apache.hc.core5.http.io.entity.EntityUtils;&#10;import org.apache.hc.core5.util.Timeout;&#10;&#10;import java.io.*;&#10;import java.nio.charset.StandardCharsets;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.nio.file.StandardCopyOption;&#10;import java.util.ArrayList;&#10;import java.util.Base64;&#10;import java.util.List;&#10;import java.util.function.Consumer;&#10;import java.util.zip.ZipEntry;&#10;import java.util.zip.ZipInputStream;&#10;import java.util.zip.GZIPInputStream;&#10;import java.util.concurrent.*;&#10;import java.util.concurrent.atomic.AtomicLong;&#10;&#10;/**&#10; * Service class for downloading and managing build artifacts from Azure DevOps&#10; * Uses ExecutorService for timeout management and retry mechanisms&#10; */&#10;public class FileDownloadService {&#10;&#10;    private final AzureConfig config;&#10;    private final ObjectMapper objectMapper;&#10;    private final CloseableHttpClient httpClient;&#10;    private final ExecutorService executorService;&#10;    &#10;    // Timeout and retry configuration&#10;    private static final int CONNECTION_TIMEOUT_MS = 60000; // 1 minute&#10;    private static final int SOCKET_TIMEOUT_MS = 900000; // 15 minutes for large files&#10;    private static final int REQUEST_TIMEOUT_MS = 1200000; // 20 minutes total request timeout&#10;    private static final int MAX_RETRY_ATTEMPTS = 3;&#10;    private static final int RETRY_DELAY_MS = 5000; // 5 seconds between retries&#10;    private static final int DOWNLOAD_TIMEOUT_MINUTES = 25; // Total download timeout via ExecutorService&#10;    &#10;    // Buffer size for file operations&#10;    private static final int BUFFER_SIZE = 64 * 1024; // 64KB buffer for better performance&#10;&#10;    public FileDownloadService(AzureConfig config) {&#10;        this.config = config;&#10;        this.objectMapper = new ObjectMapper();&#10;        this.httpClient = createHttpClient();&#10;        this.executorService = Executors.newFixedThreadPool(2); // Limited thread pool for downloads&#10;    }&#10;    &#10;    /**&#10;     * Create HTTP client with extended timeout configuration for large file downloads&#10;     */&#10;    private CloseableHttpClient createHttpClient() {&#10;        RequestConfig requestConfig = RequestConfig.custom()&#10;            .setConnectionRequestTimeout(Timeout.ofMilliseconds(CONNECTION_TIMEOUT_MS))&#10;            .setConnectTimeout(Timeout.ofMilliseconds(CONNECTION_TIMEOUT_MS))&#10;            .setResponseTimeout(Timeout.ofMilliseconds(SOCKET_TIMEOUT_MS))&#10;            .build();&#10;            &#10;        return HttpClientBuilder.create()&#10;            .setDefaultRequestConfig(requestConfig)&#10;            .evictExpiredConnections()&#10;            .evictIdleConnections(Timeout.ofMinutes(5))&#10;            .setMaxConnTotal(10)&#10;            .setMaxConnPerRoute(5)&#10;            .build();&#10;    }&#10;&#10;    /**&#10;     * Get list of available artifacts for a build with timeout and retry support&#10;     */&#10;    public List&lt;ArtifactInfo&gt; getArtifacts(String buildId, Consumer&lt;String&gt; logCallback) {&#10;        List&lt;ArtifactInfo&gt; artifacts = new ArrayList&lt;&gt;();&#10;&#10;        for (int attempt = 1; attempt &lt;= MAX_RETRY_ATTEMPTS; attempt++) {&#10;            try {&#10;                logCallback.accept(&quot;Retrieving artifacts list (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;)&quot;);&#10;                &#10;                // Use ExecutorService for timeout management&#10;                Future&lt;List&lt;ArtifactInfo&gt;&gt; future = executorService.submit(() -&gt; {&#10;                    return getArtifactsInternal(buildId, logCallback);&#10;                });&#10;                &#10;                // Wait for completion with timeout&#10;                artifacts = future.get(5, TimeUnit.MINUTES); // 5 minute timeout for artifact listing&#10;                &#10;                if (!artifacts.isEmpty()) {&#10;                    logCallback.accept(&quot;Successfully retrieved &quot; + artifacts.size() + &quot; artifacts&quot;);&#10;                    return artifacts; // Success, return immediately&#10;                }&#10;&#10;            } catch (TimeoutException e) {&#10;                logCallback.accept(&quot;Timeout retrieving artifacts (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;)&quot;);&#10;            } catch (Exception e) {&#10;                logCallback.accept(&quot;Error retrieving artifacts (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;): &quot; + e.getMessage());&#10;            }&#10;            &#10;            if (attempt &lt; MAX_RETRY_ATTEMPTS) {&#10;                try {&#10;                    logCallback.accept(&quot;Waiting &quot; + (RETRY_DELAY_MS * attempt) + &quot;ms before retry...&quot;);&#10;                    Thread.sleep(RETRY_DELAY_MS * attempt); // Exponential backoff&#10;                } catch (InterruptedException ie) {&#10;                    Thread.currentThread().interrupt();&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        &#10;        logCallback.accept(&quot;Failed to retrieve artifacts after &quot; + MAX_RETRY_ATTEMPTS + &quot; attempts&quot;);&#10;        return artifacts;&#10;    }&#10;    &#10;    /**&#10;     * Internal method to retrieve artifacts (called by ExecutorService)&#10;     */&#10;    private List&lt;ArtifactInfo&gt; getArtifactsInternal(String buildId, Consumer&lt;String&gt; logCallback) throws Exception {&#10;        List&lt;ArtifactInfo&gt; artifacts = new ArrayList&lt;&gt;();&#10;        &#10;        String artifactsUrl = String.format(&quot;%s/%s/%s/_apis/build/builds/%s/artifacts?api-version=7.0&quot;,&#10;            config.getBaseUrl(), config.getOrganization(), config.getProject(), buildId);&#10;&#10;        HttpGet getRequest = new HttpGet(artifactsUrl);&#10;        getRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;        ClassicHttpResponse response = httpClient.execute(getRequest);&#10;        HttpEntity entity = response.getEntity();&#10;        String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);&#10;&#10;        if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;            JsonNode jsonResponse = objectMapper.readTree(responseBody);&#10;            JsonNode artifactsArray = jsonResponse.get(&quot;value&quot;);&#10;&#10;            if (artifactsArray != null &amp;&amp; artifactsArray.isArray()) {&#10;                for (JsonNode artifactNode : artifactsArray) {&#10;                    ArtifactInfo artifact = new ArtifactInfo();&#10;                    artifact.setName(artifactNode.get(&quot;name&quot;).asText());&#10;                    artifact.setId(artifactNode.get(&quot;id&quot;).asText());&#10;&#10;                    JsonNode resourceNode = artifactNode.get(&quot;resource&quot;);&#10;                    if (resourceNode != null) {&#10;                        artifact.setDownloadUrl(resourceNode.get(&quot;downloadUrl&quot;).asText());&#10;                        if (resourceNode.has(&quot;properties&quot;)) {&#10;                            JsonNode propsNode = resourceNode.get(&quot;properties&quot;);&#10;                            if (propsNode.has(&quot;artifactsize&quot;)) {&#10;                                artifact.setSize(propsNode.get(&quot;artifactsize&quot;).asLong());&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    artifacts.add(artifact);&#10;                }&#10;            }&#10;        } else {&#10;            throw new RuntimeException(&quot;HTTP &quot; + response.getCode() + &quot;: &quot; + responseBody);&#10;        }&#10;        &#10;        return artifacts;&#10;    }&#10;&#10;    /**&#10;     * Download an artifact to the specified directory with timeout and retry support&#10;     */&#10;    public boolean downloadArtifact(ArtifactInfo artifact, String outputDir, Consumer&lt;String&gt; logCallback) {&#10;        for (int attempt = 1; attempt &lt;= MAX_RETRY_ATTEMPTS; attempt++) {&#10;            try {&#10;                logCallback.accept(&quot;Starting download of: &quot; + artifact.getName() + &#10;                                 &quot; (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;)&quot;);&#10;                &#10;                if (artifact.getSize() &gt; 0) {&#10;                    logCallback.accept(&quot;Artifact size: &quot; + formatFileSize(artifact.getSize()));&#10;                }&#10;                &#10;                // Use ExecutorService for timeout management&#10;                Future&lt;Boolean&gt; future = executorService.submit(() -&gt; {&#10;                    return downloadArtifactInternal(artifact, outputDir, logCallback);&#10;                });&#10;                &#10;                // Wait for completion with timeout&#10;                boolean success = future.get(DOWNLOAD_TIMEOUT_MINUTES, TimeUnit.MINUTES);&#10;                &#10;                if (success) {&#10;                    logCallback.accept(&quot;Successfully downloaded: &quot; + artifact.getName());&#10;                    return true; // Success, return immediately&#10;                }&#10;&#10;            } catch (TimeoutException e) {&#10;                logCallback.accept(&quot;Download timeout for artifact: &quot; + artifact.getName() + &#10;                                 &quot; (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;)&quot;);&#10;            } catch (Exception e) {&#10;                String errorMessage = e.getMessage();&#10;                if (errorMessage == null) {&#10;                    errorMessage = e.getClass().getSimpleName();&#10;                }&#10;                logCallback.accept(&quot;Error downloading artifact (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;): &quot; + errorMessage);&#10;            }&#10;            &#10;            if (attempt &lt; MAX_RETRY_ATTEMPTS) {&#10;                try {&#10;                    int backoffDelay = RETRY_DELAY_MS * attempt; // Exponential backoff&#10;                    logCallback.accept(&quot;Waiting &quot; + backoffDelay + &quot;ms before retry...&quot;);&#10;                    Thread.sleep(backoffDelay);&#10;                } catch (InterruptedException ie) {&#10;                    Thread.currentThread().interrupt();&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        &#10;        logCallback.accept(&quot;Failed to download artifact: &quot; + artifact.getName() + &quot; after &quot; + MAX_RETRY_ATTEMPTS + &quot; attempts&quot;);&#10;        return false;&#10;    }&#10;    &#10;    /**&#10;     * Internal method to download artifact (called by ExecutorService)&#10;     */&#10;    private boolean downloadArtifactInternal(ArtifactInfo artifact, String outputDir, Consumer&lt;String&gt; logCallback) throws Exception {&#10;        HttpGet downloadRequest = new HttpGet(artifact.getDownloadUrl());&#10;        downloadRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;        ClassicHttpResponse response = httpClient.execute(downloadRequest);&#10;&#10;        if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;            HttpEntity entity = response.getEntity();&#10;&#10;            // Create output directory if it doesn't exist&#10;            Path outputPath = Paths.get(outputDir);&#10;            Files.createDirectories(outputPath);&#10;&#10;            // Download and extract zip file&#10;            try (InputStream inputStream = entity.getContent()) {&#10;                if (artifact.getName().toLowerCase().endsWith(&quot;.zip&quot;) ||&#10;                    artifact.getDownloadUrl().contains(&quot;format=zip&quot;)) {&#10;                    extractZipFileWithProgress(inputStream, outputPath, artifact.getName(), logCallback);&#10;                } else {&#10;                    // Download as single file&#10;                    Path filePath = outputPath.resolve(artifact.getName());&#10;                    copyWithProgress(inputStream, filePath, artifact.getSize(), logCallback);&#10;&#10;                    // If the downloaded file is a .gz file, extract it in place&#10;                    if (filePath.toString().toLowerCase().endsWith(&quot;.gz&quot;)) {&#10;                        extractGzipFile(filePath, logCallback);&#10;                    }&#10;                }&#10;            }&#10;&#10;            return true;&#10;        } else {&#10;            throw new RuntimeException(&quot;HTTP &quot; + response.getCode() + &quot; downloading artifact&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract zip file contents to the specified directory&#10;     */&#10;    private void extractZipFile(InputStream zipInputStream, Path outputDir, String artifactName, Consumer&lt;String&gt; logCallback) {&#10;        try (ZipInputStream zis = new ZipInputStream(zipInputStream)) {&#10;            ZipEntry zipEntry;&#10;&#10;            while ((zipEntry = zis.getNextEntry()) != null) {&#10;                if (!zipEntry.isDirectory()) {&#10;                    Path filePath = outputDir.resolve(zipEntry.getName());&#10;&#10;                    // Create parent directories if they don't exist&#10;                    Files.createDirectories(filePath.getParent());&#10;&#10;                    try (FileOutputStream fos = new FileOutputStream(filePath.toFile())) {&#10;                        byte[] buffer = new byte[1024];&#10;                        int length;&#10;                        while ((length = zis.read(buffer)) &gt;= 0) {&#10;                            fos.write(buffer, 0, length);&#10;                        }&#10;                    }&#10;&#10;                    logCallback.accept(&quot;Extracted: &quot; + zipEntry.getName());&#10;&#10;                    // If the extracted file is a .gz file, extract it in place&#10;                    if (filePath.toString().toLowerCase().endsWith(&quot;.gz&quot;)) {&#10;                        extractGzipFile(filePath, logCallback);&#10;                    }&#10;                }&#10;                zis.closeEntry();&#10;            }&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error extracting zip file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract zip file contents with progress tracking&#10;     */&#10;    private void extractZipFileWithProgress(InputStream zipInputStream, Path outputDir, String artifactName, Consumer&lt;String&gt; logCallback) throws IOException {&#10;        try (ZipInputStream zis = new ZipInputStream(zipInputStream)) {&#10;            ZipEntry zipEntry;&#10;&#10;            while ((zipEntry = zis.getNextEntry()) != null) {&#10;                if (!zipEntry.isDirectory()) {&#10;                    Path filePath = outputDir.resolve(zipEntry.getName());&#10;&#10;                    // Create parent directories if they don't exist&#10;                    Files.createDirectories(filePath.getParent());&#10;&#10;                    logCallback.accept(&quot;Extracting: &quot; + zipEntry.getName() + &#10;                                     (zipEntry.getSize() &gt; 0 ? &quot; (&quot; + formatFileSize(zipEntry.getSize()) + &quot;)&quot; : &quot;&quot;));&#10;&#10;                    try (FileOutputStream fos = new FileOutputStream(filePath.toFile());&#10;                         BufferedOutputStream bos = new BufferedOutputStream(fos)) {&#10;                        &#10;                        byte[] buffer = new byte[BUFFER_SIZE];&#10;                        int length;&#10;                        long totalBytesRead = 0;&#10;                        &#10;                        while ((length = zis.read(buffer)) &gt;= 0) {&#10;                            bos.write(buffer, 0, length);&#10;                            totalBytesRead += length;&#10;                        }&#10;                    }&#10;&#10;                    logCallback.accept(&quot;Extracted: &quot; + zipEntry.getName() + &quot; (&quot; + formatFileSize(totalBytesRead) + &quot;)&quot;);&#10;&#10;                    // If the extracted file is a .gz file, extract it in place&#10;                    if (filePath.toString().toLowerCase().endsWith(&quot;.gz&quot;)) {&#10;                        extractGzipFile(filePath, logCallback);&#10;                    }&#10;                }&#10;                zis.closeEntry();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Copy input stream to file with progress tracking&#10;     */&#10;    private void copyWithProgress(InputStream inputStream, Path filePath, long expectedSize, Consumer&lt;String&gt; logCallback) throws IOException {&#10;        try (FileOutputStream fos = new FileOutputStream(filePath.toFile());&#10;             BufferedOutputStream bos = new BufferedOutputStream(fos);&#10;             BufferedInputStream bis = new BufferedInputStream(inputStream)) {&#10;            &#10;            byte[] buffer = new byte[BUFFER_SIZE];&#10;            int length;&#10;            long totalBytesRead = 0;&#10;            long lastLogTime = System.currentTimeMillis();&#10;            &#10;            while ((length = bis.read(buffer)) &gt;= 0) {&#10;                bos.write(buffer, 0, length);&#10;                totalBytesRead += length;&#10;                &#10;                // Log progress every 10 seconds for large files&#10;                long currentTime = System.currentTimeMillis();&#10;                if (currentTime - lastLogTime &gt; 10000) {&#10;                    if (expectedSize &gt; 0) {&#10;                        double percentage = (totalBytesRead * 100.0) / expectedSize;&#10;                        logCallback.accept(String.format(&quot;Downloaded %.1f%% (%s of %s)&quot;, &#10;                            percentage, formatFileSize(totalBytesRead), formatFileSize(expectedSize)));&#10;                    } else {&#10;                        logCallback.accept(&quot;Downloaded &quot; + formatFileSize(totalBytesRead));&#10;                    }&#10;                    lastLogTime = currentTime;&#10;                }&#10;            }&#10;            &#10;            logCallback.accept(&quot;Download completed: &quot; + filePath.getFileName() + &quot; (&quot; + formatFileSize(totalBytesRead) + &quot;)&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract a .gz file in place and remove the .gz file after extraction&#10;     */&#10;    private void extractGzipFile(Path gzipFile, Consumer&lt;String&gt; logCallback) {&#10;        try {&#10;            String originalFileName = gzipFile.getFileName().toString();&#10;            String extractedFileName = originalFileName.substring(0, originalFileName.length() - 3); // Remove .gz extension&#10;            Path extractedFile = gzipFile.getParent().resolve(extractedFileName);&#10;&#10;            logCallback.accept(&quot;Extracting gzip file: &quot; + originalFileName);&#10;&#10;            // Extract the gzip file&#10;            try (FileInputStream fis = new FileInputStream(gzipFile.toFile());&#10;                 GZIPInputStream gis = new GZIPInputStream(fis);&#10;                 FileOutputStream fos = new FileOutputStream(extractedFile.toFile())) {&#10;&#10;                byte[] buffer = new byte[1024];&#10;                int length;&#10;                while ((length = gis.read(buffer)) &gt;= 0) {&#10;                    fos.write(buffer, 0, length);&#10;                }&#10;            }&#10;&#10;            // Delete the original .gz file after successful extraction&#10;            Files.delete(gzipFile);&#10;            logCallback.accept(&quot;Successfully extracted and removed .gz file: &quot; + originalFileName + &quot; -&gt; &quot; + extractedFileName);&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error extracting gzip file &quot; + gzipFile.getFileName() + &quot;: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file preview content (first few lines)&#10;     */&#10;    public String getFilePreview(String filePath, int maxLines) {&#10;        try {&#10;            List&lt;String&gt; lines = Files.readAllLines(Paths.get(filePath));&#10;            StringBuilder preview = new StringBuilder();&#10;&#10;            int linesToRead = Math.min(maxLines, lines.size());&#10;            for (int i = 0; i &lt; linesToRead; i++) {&#10;                preview.append(lines.get(i)).append(&quot;\n&quot;);&#10;            }&#10;&#10;            if (lines.size() &gt; maxLines) {&#10;                preview.append(&quot;... (&quot;).append(lines.size() - maxLines).append(&quot; more lines)&quot;);&#10;            }&#10;&#10;            return preview.toString();&#10;        } catch (Exception e) {&#10;            return &quot;Error reading file: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download all pipeline artifacts after successful completion&#10;     * This is the main orchestration method that should be called after pipeline success&#10;     */&#10;    public List&lt;Path&gt; downloadPipelineArtifacts(String buildId, String flightNumber, Consumer&lt;String&gt; logCallback) {&#10;        List&lt;Path&gt; downloadedFiles = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            logCallback.accept(&quot;Starting artifact discovery and download for build: &quot; + buildId);&#10;&#10;            // Step 1: Get list of available artifacts from Azure DevOps&#10;            List&lt;ArtifactInfo&gt; artifacts = getArtifacts(buildId, logCallback);&#10;&#10;            if (artifacts.isEmpty()) {&#10;                logCallback.accept(&quot;No artifacts found for build &quot; + buildId);&#10;                return downloadedFiles;&#10;            }&#10;&#10;            logCallback.accept(&quot;Found &quot; + artifacts.size() + &quot; artifacts to download&quot;);&#10;&#10;            // Step 2: Create download directory&#10;            String downloadDir = createDownloadDirectory(flightNumber);&#10;            logCallback.accept(&quot;Download directory: &quot; + downloadDir);&#10;&#10;            // Step 3: Download each artifact&#10;            for (ArtifactInfo artifact : artifacts) {&#10;                logCallback.accept(&quot;Downloading artifact: &quot; + artifact.getName());&#10;&#10;                boolean success = downloadArtifact(artifact, downloadDir, logCallback);&#10;&#10;                if (success) {&#10;                    // Step 4: Find and collect downloaded files&#10;                    List&lt;Path&gt; extractedFiles = findExtractedFiles(downloadDir, artifact.getName(), logCallback);&#10;                    downloadedFiles.addAll(extractedFiles);&#10;                } else {&#10;                    logCallback.accept(&quot;Failed to download artifact: &quot; + artifact.getName());&#10;                }&#10;            }&#10;&#10;            logCallback.accept(&quot;Download completed. Total files: &quot; + downloadedFiles.size());&#10;&#10;            // Step 5: Log summary of downloaded files&#10;            for (Path file : downloadedFiles) {&#10;                logCallback.accept(&quot;Downloaded file: &quot; + file.getFileName() + &quot; (&quot; + getFileSize(file) + &quot;)&quot;);&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error downloading pipeline artifacts: &quot; + e.getMessage());&#10;        }&#10;&#10;        return downloadedFiles;&#10;    }&#10;&#10;    /**&#10;     * Create a download directory for the flight&#10;     */&#10;    private String createDownloadDirectory(String flightNumber) throws IOException {&#10;        String userHome = System.getProperty(&quot;user.home&quot;);&#10;        String downloadDir = String.format(&quot;%s/Downloads/L3Engine_Logs/%s_%s&quot;,&#10;            userHome,&#10;            flightNumber,&#10;            java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd_HHmmss&quot;))&#10;        );&#10;&#10;        Path downloadPath = Paths.get(downloadDir);&#10;        Files.createDirectories(downloadPath);&#10;&#10;        return downloadDir;&#10;    }&#10;&#10;    /**&#10;     * Find all extracted files from an artifact download&#10;     */&#10;    private List&lt;Path&gt; findExtractedFiles(String downloadDir, String artifactName, Consumer&lt;String&gt; logCallback) {&#10;        List&lt;Path&gt; files = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            Path dirPath = Paths.get(downloadDir);&#10;&#10;            Files.walk(dirPath)&#10;                 .filter(Files::isRegularFile)&#10;                 .filter(path -&gt; isLogFile(path))&#10;                 .forEach(files::add);&#10;&#10;            logCallback.accept(&quot;Found &quot; + files.size() + &quot; log files in &quot; + artifactName);&#10;&#10;        } catch (Exception e) {&#10;            logCallback.accept(&quot;Error finding extracted files: &quot; + e.getMessage());&#10;        }&#10;&#10;        return files;&#10;    }&#10;&#10;    /**&#10;     * Check if a file is a log file based on extension or name patterns&#10;     */&#10;    private boolean isLogFile(Path file) {&#10;        String fileName = file.getFileName().toString().toLowerCase();&#10;        return fileName.endsWith(&quot;.log&quot;) ||&#10;               fileName.endsWith(&quot;.txt&quot;) ||&#10;               fileName.contains(&quot;log&quot;) ||&#10;               fileName.endsWith(&quot;.csv&quot;) ||&#10;               fileName.endsWith(&quot;.json&quot;) ||&#10;               fileName.endsWith(&quot;.gz&quot;); // Include .gz files as they often contain compressed logs&#10;    }&#10;&#10;    /**&#10;     * Get formatted file size&#10;     */&#10;    private String getFileSize(Path file) {&#10;        try {&#10;            long bytes = Files.size(file);&#10;            return formatFileSize(bytes);&#10;        } catch (Exception e) {&#10;            return &quot;Unknown size&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format file size in human readable format&#10;     */&#10;    private String formatFileSize(long bytes) {&#10;        if (bytes &lt; 1024) return bytes + &quot; B&quot;;&#10;        int exp = (int) (Math.log(bytes) / Math.log(1024));&#10;        String pre = &quot;KMGTPE&quot;.charAt(exp - 1) + &quot;&quot;;&#10;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(1024, exp), pre);&#10;    }&#10;&#10;    private String getEncodedAuth() {&#10;        String auth = &quot;:&quot; + config.getPersonalAccessToken();&#10;        return Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));&#10;    }&#10;&#10;    public void close() throws IOException {&#10;        try {&#10;            // Shutdown executor service gracefully&#10;            executorService.shutdown();&#10;            if (!executorService.awaitTermination(30, TimeUnit.SECONDS)) {&#10;                executorService.shutdownNow();&#10;            }&#10;        } catch (InterruptedException e) {&#10;            executorService.shutdownNow();&#10;            Thread.currentThread().interrupt();&#10;        } finally {&#10;            httpClient.close();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Force shutdown of all resources&#10;     */&#10;    public void forceShutdown() {&#10;        try {&#10;            executorService.shutdownNow();&#10;            httpClient.close();&#10;        } catch (IOException e) {&#10;            // Log error but don't throw&#10;            System.err.println(&quot;Error closing HTTP client: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get file names from a zip artifact without downloading the entire artifact&#10;     */&#10;    public List&lt;String&gt; getFileNamesFromArtifact(ArtifactInfo artifact) {&#10;        List&lt;String&gt; fileNames = new ArrayList&lt;&gt;();&#10;&#10;        try {&#10;            HttpGet downloadRequest = new HttpGet(artifact.getDownloadUrl());&#10;            downloadRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;            ClassicHttpResponse response = httpClient.execute(downloadRequest);&#10;&#10;            if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;                HttpEntity entity = response.getEntity();&#10;&#10;                // Read the zip file and extract file names&#10;                try (InputStream inputStream = entity.getContent();&#10;                     ZipInputStream zis = new ZipInputStream(inputStream)) {&#10;&#10;                    ZipEntry zipEntry;&#10;                    while ((zipEntry = zis.getNextEntry()) != null) {&#10;                        if (!zipEntry.isDirectory()) {&#10;                            String fileName = zipEntry.getName();&#10;                            // Extract just the filename without directory path&#10;                            if (fileName.contains(&quot;/&quot;)) {&#10;                                fileName = fileName.substring(fileName.lastIndexOf(&quot;/&quot;) + 1);&#10;                            }&#10;                            if (fileName.contains(&quot;\\&quot;)) {&#10;                                fileName = fileName.substring(fileName.lastIndexOf(&quot;\\&quot;) + 1);&#10;                            }&#10;                            if (!fileName.isEmpty() &amp;&amp; isLogFile(Paths.get(fileName))) {&#10;                                fileNames.add(fileName);&#10;                            }&#10;                        }&#10;                        zis.closeEntry();&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (Exception e) {&#10;            // If we can't read the zip, return empty list&#10;        }&#10;&#10;        return fileNames;&#10;    }&#10;&#10;    /**&#10;     * Download a specific file from an artifact with timeout and retry support&#10;     */&#10;    public boolean downloadSpecificFile(ArtifactInfo artifact, String specificFileName, String outputDir, Consumer&lt;String&gt; logCallback) {&#10;        if (specificFileName == null) {&#10;            // If no specific file requested, download the entire artifact&#10;            return downloadArtifact(artifact, outputDir, logCallback);&#10;        }&#10;&#10;        for (int attempt = 1; attempt &lt;= MAX_RETRY_ATTEMPTS; attempt++) {&#10;            try {&#10;                logCallback.accept(&quot;Downloading specific file: &quot; + specificFileName + &quot; from artifact: &quot; + artifact.getName() + &#10;                                 &quot; (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;)&quot;);&#10;&#10;                // Use ExecutorService for timeout management&#10;                Future&lt;Boolean&gt; future = executorService.submit(() -&gt; {&#10;                    return downloadSpecificFileInternal(artifact, specificFileName, outputDir, logCallback);&#10;                });&#10;                &#10;                // Wait for completion with extended timeout for large files&#10;                boolean success = future.get(DOWNLOAD_TIMEOUT_MINUTES, TimeUnit.MINUTES);&#10;                &#10;                if (success) {&#10;                    return true; // Success, return immediately&#10;                }&#10;&#10;            } catch (TimeoutException e) {&#10;                logCallback.accept(&quot;Download timeout for file: &quot; + specificFileName + &#10;                                 &quot; (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;)&quot;);&#10;                logCallback.accept(&quot;This timeout may be due to large file size or network issues&quot;);&#10;            } catch (Exception e) {&#10;                String errorMessage = e.getMessage();&#10;                if (errorMessage == null) {&#10;                    errorMessage = e.getClass().getSimpleName();&#10;                }&#10;                logCallback.accept(&quot;Error downloading specific file (attempt &quot; + attempt + &quot;/&quot; + MAX_RETRY_ATTEMPTS + &quot;): &quot; + errorMessage);&#10;            }&#10;            &#10;            if (attempt &lt; MAX_RETRY_ATTEMPTS) {&#10;                try {&#10;                    int backoffDelay = RETRY_DELAY_MS * attempt; // Exponential backoff&#10;                    logCallback.accept(&quot;Waiting &quot; + backoffDelay + &quot;ms before retry...&quot;);&#10;                    Thread.sleep(backoffDelay);&#10;                } catch (InterruptedException ie) {&#10;                    Thread.currentThread().interrupt();&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;        &#10;        logCallback.accept(&quot;Failed to download specific file: &quot; + specificFileName + &quot; after &quot; + MAX_RETRY_ATTEMPTS + &quot; attempts&quot;);&#10;        return false;&#10;    }&#10;    &#10;    /**&#10;     * Internal method to download specific file (called by ExecutorService)&#10;     */&#10;    private boolean downloadSpecificFileInternal(ArtifactInfo artifact, String specificFileName, String outputDir, Consumer&lt;String&gt; logCallback) throws Exception {&#10;        HttpGet downloadRequest = new HttpGet(artifact.getDownloadUrl());&#10;        downloadRequest.setHeader(&quot;Authorization&quot;, &quot;Basic &quot; + getEncodedAuth());&#10;&#10;        ClassicHttpResponse response = httpClient.execute(downloadRequest);&#10;&#10;        if (response.getCode() &gt;= 200 &amp;&amp; response.getCode() &lt; 300) {&#10;            HttpEntity entity = response.getEntity();&#10;&#10;            // Create output directory if it doesn't exist&#10;            Path outputPath = Paths.get(outputDir);&#10;            Files.createDirectories(outputPath);&#10;&#10;            // Extract only the specific file from the zip&#10;            try (InputStream inputStream = entity.getContent();&#10;                 ZipInputStream zis = new ZipInputStream(inputStream)) {&#10;&#10;                ZipEntry zipEntry;&#10;                while ((zipEntry = zis.getNextEntry()) != null) {&#10;                    if (!zipEntry.isDirectory()) {&#10;                        String fileName = zipEntry.getName();&#10;                        // Extract just the filename without directory path&#10;                        String baseFileName = fileName;&#10;                        if (fileName.contains(&quot;/&quot;)) {&#10;                            baseFileName = fileName.substring(fileName.lastIndexOf(&quot;/&quot;) + 1);&#10;                        }&#10;                        if (fileName.contains(&quot;\\&quot;)) {&#10;                            baseFileName = fileName.substring(fileName.lastIndexOf(&quot;\\&quot;) + 1);&#10;                        }&#10;&#10;                        // Check if this is the file we're looking for&#10;                        if (baseFileName.equals(specificFileName)) {&#10;                            Path filePath = outputPath.resolve(baseFileName);&#10;&#10;                            logCallback.accept(&quot;Extracting file: &quot; + baseFileName + &#10;                                             (zipEntry.getSize() &gt; 0 ? &quot; (size: &quot; + formatFileSize(zipEntry.getSize()) + &quot;)&quot; : &quot;&quot;));&#10;&#10;                            // Use buffered copying with progress tracking&#10;                            AtomicLong totalBytesRead = new AtomicLong(0);&#10;                            try (FileOutputStream fos = new FileOutputStream(filePath.toFile());&#10;                                 BufferedOutputStream bos = new BufferedOutputStream(fos)) {&#10;                                &#10;                                byte[] buffer = new byte[BUFFER_SIZE];&#10;                                int length;&#10;                                long lastLogTime = System.currentTimeMillis();&#10;                                &#10;                                while ((length = zis.read(buffer)) &gt;= 0) {&#10;                                    bos.write(buffer, 0, length);&#10;                                    totalBytesRead.addAndGet(length);&#10;                                    &#10;                                    // Log progress every 10 seconds for large files&#10;                                    long currentTime = System.currentTimeMillis();&#10;                                    if (currentTime - lastLogTime &gt; 10000) {&#10;                                        logCallback.accept(&quot;Downloaded &quot; + formatFileSize(totalBytesRead.get()) + &quot; of &quot; + baseFileName);&#10;                                        lastLogTime = currentTime;&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            logCallback.accept(&quot;Successfully extracted: &quot; + baseFileName + &quot; (&quot; + formatFileSize(totalBytesRead.get()) + &quot;)&quot;);&#10;&#10;                            // If the extracted file is a .gz file, extract it in place&#10;                            if (filePath.toString().toLowerCase().endsWith(&quot;.gz&quot;)) {&#10;                                extractGzipFile(filePath, logCallback);&#10;                            }&#10;&#10;                            zis.closeEntry();&#10;                            return true;&#10;                        }&#10;                    }&#10;                    zis.closeEntry();&#10;                }&#10;            }&#10;&#10;            throw new RuntimeException(&quot;File not found in artifact: &quot; + specificFileName);&#10;        } else {&#10;            throw new RuntimeException(&quot;HTTP &quot; + response.getCode() + &quot; downloading artifact&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Class representing artifact information&#10;     */&#10;    public static class ArtifactInfo {&#10;        private String name;&#10;        private String id;&#10;        private String downloadUrl;&#10;        private long size;&#10;&#10;        // Getters and setters&#10;        public String getName() { return name; }&#10;        public void setName(String name) { this.name = name; }&#10;&#10;        public String getId() { return id; }&#10;        public void setId(String id) { this.id = id; }&#10;&#10;        public String getDownloadUrl() { return downloadUrl; }&#10;        public void setDownloadUrl(String downloadUrl) { this.downloadUrl = downloadUrl; }&#10;&#10;        public long getSize() { return size; }&#10;        public void setSize(long size) { this.size = size; }&#10;&#10;        @Override&#10;        public String toString() {&#10;            return String.format(&quot;ArtifactInfo{name='%s', id='%s', size=%d}&quot;, name, id, size);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/controller/PnrExtractionController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/controller/PnrExtractionController.java" />
              <option name="updatedContent" value="package com.l3.logparser.pnr.controller;&#10;&#10;import com.l3.logparser.pnr.model.PnrMessage;&#10;import com.l3.logparser.pnr.service.PnrExtractionService;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.Initializable;&#10;import javafx.scene.control.*;&#10;&#10;import java.net.URL;&#10;import java.util.ResourceBundle;&#10;&#10;/**&#10; * Controller for PNR extraction functionality&#10; * This will be developed independently from the API controller&#10; */&#10;public class PnrExtractionController implements Initializable {&#10;    &#10;    @FXML private TextField logDirectoryField;&#10;    @FXML private TextField flightNumberField;&#10;    @FXML private TextField pnrReferenceField;&#10;    @FXML private Button processButton;&#10;    @FXML private TableView&lt;PnrMessage&gt; resultsTable;&#10;    @FXML private TextArea logArea;&#10;    &#10;    private PnrExtractionService pnrExtractionService;&#10;    &#10;    @Override&#10;    public void initialize(URL location, ResourceBundle resources) {&#10;        pnrExtractionService = new PnrExtractionService();&#10;        setupUI();&#10;        // TODO: Setup table columns for PNR-specific data&#10;    }&#10;    &#10;    private void setupUI() {&#10;        // TODO: Initialize PNR-specific UI components&#10;        pnrReferenceField.setPromptText(&quot;e.g., ABC123&quot;);&#10;        flightNumberField.setPromptText(&quot;e.g., MS775&quot;);&#10;    }&#10;    &#10;    @FXML&#10;    private void onProcessPnrLogs() {&#10;        // TODO: Implement PNR log processing&#10;        String logDirectory = logDirectoryField.getText().trim();&#10;        String flightNumber = flightNumberField.getText().trim();&#10;        String pnrReference = pnrReferenceField.getText().trim();&#10;        &#10;        if (logDirectory.isEmpty()) {&#10;            showAlert(&quot;Error&quot;, &quot;Please select a log directory&quot;);&#10;            return;&#10;        }&#10;        &#10;        // TODO: Create background task for PNR extraction&#10;    }&#10;    &#10;    private void showAlert(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/model/PnrDetails.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/model/PnrDetails.java" />
              <option name="updatedContent" value="package com.l3.logparser.pnr.model;&#10;&#10;/**&#10; * Model representing PNR-specific details extracted from logs&#10; */&#10;public class PnrDetails {&#10;    private String pnrReference;&#10;    private String bookingDate;&#10;    private String passengerCount;&#10;    private String flightDetails;&#10;    private String bookingStatus;&#10;    &#10;    public PnrDetails() {}&#10;    &#10;    // Getters and Setters&#10;    public String getPnrReference() { return pnrReference; }&#10;    public void setPnrReference(String pnrReference) { this.pnrReference = pnrReference; }&#10;    &#10;    public String getBookingDate() { return bookingDate; }&#10;    public void setBookingDate(String bookingDate) { this.bookingDate = bookingDate; }&#10;    &#10;    public String getPassengerCount() { return passengerCount; }&#10;    public void setPassengerCount(String passengerCount) { this.passengerCount = passengerCount; }&#10;    &#10;    public String getFlightDetails() { return flightDetails; }&#10;    public void setFlightDetails(String flightDetails) { this.flightDetails = flightDetails; }&#10;    &#10;    public String getBookingStatus() { return bookingStatus; }&#10;    public void setBookingStatus(String bookingStatus) { this.bookingStatus = bookingStatus; }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return &quot;PnrDetails{&quot; +&#10;                &quot;pnrReference='&quot; + pnrReference + '\'' +&#10;                &quot;, bookingDate='&quot; + bookingDate + '\'' +&#10;                &quot;, passengerCount='&quot; + passengerCount + '\'' +&#10;                &quot;, bookingStatus='&quot; + bookingStatus + '\'' +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/parser/PnrParser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/parser/PnrParser.java" />
              <option name="updatedContent" value="package com.l3.logparser.pnr.parser;&#10;&#10;import com.l3.logparser.pnr.model.PnrMessage;&#10;import com.l3.logparser.pnr.model.PnrDetails;&#10;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;/**&#10; * Parser for PNR messages found in log files&#10; * Handles PNR-specific parsing logic separate from API parsing&#10; */&#10;public class PnrParser {&#10;    &#10;    /**&#10;     * Parse log content to extract PNR messages&#10;     * @param logContent The raw log file content&#10;     * @param targetFlightNumber Optional flight number filter&#10;     * @return List of extracted PNR messages&#10;     */&#10;    public List&lt;PnrMessage&gt; parseLogContent(String logContent, String targetFlightNumber) {&#10;        List&lt;PnrMessage&gt; messages = new ArrayList&lt;&gt;();&#10;        &#10;        // TODO: Implement PNR-specific parsing logic&#10;        // This will be different from API EDIFACT parsing&#10;        // PNR logs may have different formats and patterns&#10;        &#10;        return messages;&#10;    }&#10;    &#10;    /**&#10;     * Parse PNR details from a specific message format&#10;     * @param messageContent The PNR message content&#10;     * @return PnrDetails object with extracted information&#10;     */&#10;    private PnrDetails parsePnrDetails(String messageContent) {&#10;        PnrDetails details = new PnrDetails();&#10;        &#10;        // TODO: Implement PNR details extraction&#10;        // Parse booking reference, passenger info, etc.&#10;        &#10;        return details;&#10;    }&#10;    &#10;    /**&#10;     * Check if a PNR message matches the flight criteria&#10;     * @param message The PNR message to check&#10;     * @param targetFlightNumber The target flight number&#10;     * @return true if matches, false otherwise&#10;     */&#10;    private boolean matchesFlightCriteria(PnrMessage message, String targetFlightNumber) {&#10;        if (targetFlightNumber == null || targetFlightNumber.trim().isEmpty()) {&#10;            return true;&#10;        }&#10;        &#10;        // TODO: Implement PNR-specific flight matching logic&#10;        &#10;        return false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/l3/logextractor/test/FXMLTestApp.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/l3/logextractor/test/FXMLTestApp.java" />
              <option name="updatedContent" value="package com.l3.logextractor.test;&#10;&#10;import javafx.application.Application;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Scene;&#10;import javafx.stage.Stage;&#10;&#10;/**&#10; * Simple test application to verify FXML loads correctly&#10; */&#10;public class FXMLTestApp extends Application {&#10;&#10;    @Override&#10;    public void start(Stage primaryStage) {&#10;        try {&#10;            FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;/com/l3/rcaengine/api/log-extraction-view.fxml&quot;));&#10;            Scene scene = new Scene(loader.load(), 1025, 916);&#10;            &#10;            primaryStage.setTitle(&quot;Log Extraction Module - Test&quot;);&#10;            primaryStage.setScene(scene);&#10;            primaryStage.show();&#10;            &#10;            System.out.println(&quot;FXML loaded successfully!&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading FXML: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        launch(args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/l3/logparser/config/AdvancedConfigTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/l3/logparser/config/AdvancedConfigTest.java" />
              <option name="updatedContent" value="package com.l3.logparser.config;&#10;&#10;/**&#10; * Simple test class to verify advanced configuration functionality&#10; */&#10;public class AdvancedConfigTest {&#10;    &#10;    public static void main(String[] args) {&#10;        testAdvancedConfig();&#10;        testApiPatternConfig();&#10;        testConfigPersistence();&#10;    }&#10;    &#10;    private static void testAdvancedConfig() {&#10;        System.out.println(&quot;=== Testing AdvancedParserConfig ===&quot;);&#10;        &#10;        // Create new config&#10;        AdvancedParserConfig config = new AdvancedParserConfig();&#10;        &#10;        // Test default patterns&#10;        ApiPatternConfig apiConfig = config.getApiConfig();&#10;        System.out.println(&quot;Default patterns loaded: &quot; + apiConfig.getMessageStartPatterns().size());&#10;        &#10;        for (ApiPatternConfig.MessagePattern pattern : apiConfig.getMessageStartPatterns()) {&#10;            System.out.println(&quot;Pattern: &quot; + pattern.getName() + &quot; (&quot; + pattern.getType() + &quot;) - &quot; + &#10;                               (pattern.isEnabled() ? &quot;ENABLED&quot; : &quot;DISABLED&quot;));&#10;        }&#10;        &#10;        // Test segment codes&#10;        ApiPatternConfig.SegmentCodes codes = apiConfig.getSegmentCodes();&#10;        System.out.println(&quot;BGM Passenger Code: &quot; + codes.getBgmPassengerCode());&#10;        System.out.println(&quot;LOC Departure Code: &quot; + codes.getLocDepartureCode());&#10;        System.out.println(&quot;DTM Departure Code: &quot; + codes.getDtmDepartureCode());&#10;        System.out.println(&quot;TDT Flight Position: &quot; + codes.getTdtFlightPosition());&#10;    }&#10;    &#10;    private static void testApiPatternConfig() {&#10;        System.out.println(&quot;\n=== Testing ApiPatternConfig ===&quot;);&#10;        &#10;        ApiPatternConfig config = new ApiPatternConfig();&#10;        config.loadDefaults();&#10;        &#10;        // Test adding a new pattern&#10;        ApiPatternConfig.MessagePattern newPattern = &#10;            new ApiPatternConfig.MessagePattern(&quot;TEST_PATTERN&quot;, &quot;contains&quot;, &quot;TEST_VALUE&quot;, true);&#10;        config.getMessageStartPatterns().add(newPattern);&#10;        &#10;        System.out.println(&quot;Added new pattern. Total patterns: &quot; + config.getMessageStartPatterns().size());&#10;        &#10;        // Test modifying segment codes&#10;        config.getSegmentCodes().setBgmPassengerCode(&quot;999&quot;);&#10;        System.out.println(&quot;Modified BGM passenger code: &quot; + config.getSegmentCodes().getBgmPassengerCode());&#10;    }&#10;    &#10;    private static void testConfigPersistence() {&#10;        System.out.println(&quot;\n=== Testing Configuration Persistence ===&quot;);&#10;        &#10;        try {&#10;            // Create and modify config&#10;            AdvancedParserConfig config = new AdvancedParserConfig();&#10;            config.getApiConfig().getSegmentCodes().setBgmPassengerCode(&quot;777&quot;);&#10;            &#10;            // Save to file&#10;            boolean saveSuccess = config.saveToFile();&#10;            System.out.println(&quot;Save to file: &quot; + (saveSuccess ? &quot;SUCCESS&quot; : &quot;FAILED&quot;));&#10;            &#10;            // Load new instance&#10;            AdvancedParserConfig loadedConfig = new AdvancedParserConfig();&#10;            String loadedCode = loadedConfig.getApiConfig().getSegmentCodes().getBgmPassengerCode();&#10;            System.out.println(&quot;Loaded BGM passenger code: &quot; + loadedCode);&#10;            &#10;            // Check if persistence worked&#10;            System.out.println(&quot;Persistence test: &quot; + (&quot;777&quot;.equals(loadedCode) ? &quot;SUCCESS&quot; : &quot;FAILED&quot;));&#10;            &#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Persistence test FAILED: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>