<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ApiParserTestDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ApiParserTestDemo.java" />
              <option name="updatedContent" value="import com.l3.logparser.api.parser.ApiParser;&#10;import com.l3.logparser.api.model.EdifactMessage;&#10;import java.util.List;&#10;&#10;/**&#10; * Simple demonstration of the refactored two-stage ApiParser&#10; */&#10;public class ApiParserTestDemo {&#10;    &#10;    public static void main(String[] args) {&#10;        ApiParser parser = new ApiParser();&#10;        &#10;        // Sample log content with EDIFACT message&#10;        String logContent = &quot;2024-11-30 10:15:23 INFO  [Thread-1] com.example.Forward.BUSINESS_RULES_PROCESSOR - Message body [UNA:+.?'UNB+IATB:1+6X+FRAORD+240725+1130+TS2302507251130'UNH+TS2302507251130+PAXLST:D:05B:UN:IATA+TS2302507251130'BGM+745+TS2302507251130'TDT+20+MS775++MS'LOC+125+FRA'LOC+87+ORD'DTM+189:24072511:30'UNZ+1+TS2302507251130']&quot;;&#10;        &#10;        // Test parsing with debug mode&#10;        List&lt;EdifactMessage&gt; messages = parser.parseLogContent(logContent, &quot;MS775&quot;, true, &#10;            debugMsg -&gt; System.out.println(&quot;[DEBUG] &quot; + debugMsg));&#10;        &#10;        System.out.println(&quot;\n=== PARSING RESULTS ===&quot;);&#10;        System.out.println(&quot;Found &quot; + messages.size() + &quot; messages&quot;);&#10;        &#10;        for (int i = 0; i &lt; messages.size(); i++) {&#10;            EdifactMessage msg = messages.get(i);&#10;            System.out.println(&quot;\nMessage &quot; + (i + 1) + &quot;:&quot;);&#10;            System.out.println(&quot;  Flight Number: &quot; + msg.getFlightNumber());&#10;            System.out.println(&quot;  Message ID: &quot; + msg.getMessageId());&#10;            System.out.println(&quot;  Data Type: &quot; + msg.getDataType());&#10;            System.out.println(&quot;  Part Number: &quot; + msg.getPartNumber());&#10;            System.out.println(&quot;  Part Indicator: &quot; + msg.getPartIndicator());&#10;            &#10;            if (msg.getFlightDetails() != null) {&#10;                System.out.println(&quot;  Flight Details:&quot;);&#10;                System.out.println(&quot;    Departure: &quot; + msg.getFlightDetails().getDepartureAirport());&#10;                System.out.println(&quot;    Arrival: &quot; + msg.getFlightDetails().getArrivalAirport());&#10;                System.out.println(&quot;    Departure Date: &quot; + msg.getFlightDetails().getDepartureDate());&#10;                System.out.println(&quot;    Departure Time: &quot; + msg.getFlightDetails().getDepartureTime());&#10;            }&#10;            &#10;            System.out.println(&quot;  Raw Content Length: &quot; + &#10;                (msg.getRawContent() != null ? msg.getRawContent().length() : 0) + &quot; chars&quot;);&#10;        }&#10;        &#10;        System.out.println(&quot;\n=== TWO-STAGE PARSING COMPLETE ===&quot;);&#10;        System.out.println(&quot;Stage 1: Extract message boundaries (start patterns to UNZ)&quot;);&#10;        System.out.println(&quot;Stage 2: Parse each message character-by-character using separators&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PROJECT_RETROSPECTIVE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PROJECT_RETROSPECTIVE.md" />
              <option name="updatedContent" value="# L3 Engine - Log Extraction Tool&#10;## Project Retrospective Brief&#10;&#10;### Project Vision &amp; Goals&#10;&#10;**What We Set Out to Build:**&#10;The L3 Engine Log Extraction Tool was conceived to address a critical operational challenge faced by our airline operations team. When flight incidents occur, our support engineers need to quickly gather and analyze relevant log files from multiple systems to perform root cause analysis and resolve issues.&#10;&#10;**The Problem We Aimed to Solve:**&#10;- **Manual Log Collection**: Engineers were spending hours manually collecting log files from various systems across different servers&#10;- **Time-Critical Analysis**: Flight incidents require rapid response, but log collection was becoming a bottleneck&#10;- **Scattered Data Sources**: Log files were distributed across multiple systems (DAS, MessageTypeB, MessageAPI, MessageForwarder)&#10;- **Inconsistent Process**: Different engineers had different approaches to log collection, leading to missed files or incomplete data sets&#10;&#10;### Technical Architecture Decision&#10;&#10;**Core Design Philosophy:**&#10;We designed the tool around a **pipeline-driven artifact collection** model, leveraging Azure DevOps pipelines to orchestrate log gathering from remote systems, then automatically downloading and organizing the results.&#10;&#10;**Key Components:**&#10;1. **Azure Pipeline Integration**: Trigger remote log collection processes via Azure DevOps API&#10;2. **Artifact Management**: Download and extract build artifacts containing collected logs&#10;3. **JavaFX Desktop Application**: Provide an intuitive interface for operations teams&#10;4. **Message Extraction Engine**: Parse and analyze collected logs for specific flight data&#10;&#10;### Expected Benefits&#10;&#10;**Operational Efficiency:**&#10;- Reduce log collection time from hours to minutes&#10;- Standardize the log collection process across all engineers&#10;- Enable faster incident response and resolution&#10;&#10;**Data Completeness:**&#10;- Ensure all relevant log sources are consistently collected&#10;- Reduce risk of missing critical log files during incident analysis&#10;- Provide comprehensive artifact organization and preview capabilities&#10;&#10;**Team Productivity:**&#10;- Free up engineering time from manual log gathering tasks&#10;- Enable focus on actual analysis and problem-solving&#10;- Provide self-service capabilities for operations teams&#10;&#10;### Implementation Approach&#10;&#10;**Phase 1: Core Infrastructure**&#10;- Azure DevOps pipeline integration for triggering remote log collection&#10;- Build artifact download and extraction capabilities&#10;- Basic desktop application framework with JavaFX&#10;&#10;**Phase 2: Enhanced Features**&#10;- Real-time pipeline status monitoring&#10;- File preview and organization capabilities&#10;- Configuration management for different environments&#10;&#10;**Phase 3: Analysis Integration**&#10;- Message parsing and extraction from collected logs&#10;- Root cause analysis reporting features&#10;- Integration with existing operational workflows&#10;&#10;### Success Metrics&#10;&#10;**Performance Targets:**&#10;- Reduce log collection time by 80% (from 2-4 hours to 15-30 minutes)&#10;- Achieve 99%+ collection reliability across all target log sources&#10;- Support parallel processing of multiple flight incidents&#10;&#10;**Quality Indicators:**&#10;- Zero missed log files during collection process&#10;- Standardized file organization and naming conventions&#10;- Comprehensive audit trail of collection activities&#10;&#10;### Risk Mitigation Strategies&#10;&#10;**Technical Risks:**&#10;- **Azure DevOps Dependency**: Implemented robust error handling and retry mechanisms&#10;- **Network Connectivity**: Added offline preview capabilities and local caching&#10;- **Authentication Issues**: Comprehensive token validation and detailed error messaging&#10;&#10;**Operational Risks:**&#10;- **User Training**: Designed intuitive interface requiring minimal training&#10;- **Process Changes**: Maintained backward compatibility with existing workflows&#10;- **System Integration**: Flexible configuration system for different environments&#10;&#10;---&#10;&#10;*This retrospective represents the project vision and planning that guided the development of the L3 Engine Log Extraction Tool. The tool successfully addresses critical operational needs by automating and standardizing the log collection process for flight incident analysis.*" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/error_codes_appendix.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/error_codes_appendix.md" />
              <option name="updatedContent" value="---&#10;&#10;## Appendix B: Error Codes Reference&#10;&#10;L3 Engine uses standardized error codes to help you quickly identify and resolve issues. Each error includes a specific code, description, and resolution steps.&#10;&#10;### B.1 Log Extraction Engine Errors (LE001-LE005)&#10;&#10;| Error Code | Description | What It Means | How to Fix |&#10;|------------|-------------|---------------|------------|&#10;| **LE001** | Azure configuration missing | Azure DevOps connection is not configured | Click the ⚙ Configure Azure button and enter your organization URL, project name, and Personal Access Token |&#10;| **LE002** | Invalid credentials | Your Personal Access Token is incorrect or expired | 1. Check your token is copied correctly&lt;br&gt;2. Generate a new token at Azure DevOps&lt;br&gt;3. Ensure token has Build and Release permissions |&#10;| **LE003** | Pipeline trigger failed | The extraction pipeline failed to start or execute | 1. Verify the flight operated on the specified date&lt;br&gt;2. Check Azure DevOps is accessible&lt;br&gt;3. Wait a few minutes and try again |&#10;| **LE004** | Network connectivity error | Cannot connect to Azure DevOps | 1. Check your internet connection&lt;br&gt;2. Verify Azure DevOps URL is correct&lt;br&gt;3. Contact IT if firewall may be blocking access |&#10;| **LE005** | Insufficient permissions | Your account lacks necessary Azure DevOps permissions | Contact your Azure DevOps administrator to grant Build and Release permissions |&#10;&#10;### B.2 Log Parser Engine Errors (LP001-LP005)&#10;&#10;| Error Code | Description | What It Means | How to Fix |&#10;|------------|-------------|---------------|------------|&#10;| **LP001** | Invalid directory path | The selected log directory is invalid or inaccessible | 1. Ensure the directory exists&lt;br&gt;2. Check you have read permissions&lt;br&gt;3. Select a different directory |&#10;| **LP002** | No EDIFACT messages found | No passenger data found in the log files | 1. Verify logs contain passenger data&lt;br&gt;2. Check flight number and date accuracy&lt;br&gt;3. Try different data type (API ↔ PNR) |&#10;| **LP003** | Message parsing failed | Error processing passenger message format | 1. Verify flight number format (minimum 3 characters)&lt;br&gt;2. Ensure departure date is selected&lt;br&gt;3. Contact development team if issue persists |&#10;| **LP004** | Multi-node consolidation error | Failed to combine logs from multiple nodes | 1. Check n1/, n2/, n3/ subdirectories exist&lt;br&gt;2. Disable multi-node mode if not needed&lt;br&gt;3. Ensure subdirectories contain log files |&#10;| **LP005** | File format not supported | The log file format cannot be processed | 1. Verify you're using standard application log files&lt;br&gt;2. Check files aren't corrupted&lt;br&gt;3. Contact support for format assistance |&#10;&#10;### B.3 RCA Engine Errors (RCA001-RCA005)&#10;&#10;| Error Code | Description | What It Means | How to Fix |&#10;|------------|-------------|---------------|------------|&#10;| **RCA001** | No passenger files found | No data files available for analysis | 1. Select a folder containing input/ and output/ subdirectories&lt;br&gt;2. Process logs through Log Parser Engine first&lt;br&gt;3. Verify folder contains passenger data files |&#10;| **RCA002** | File parsing error | Error reading or processing passenger data files | 1. Ensure files weren't manually modified&lt;br&gt;2. Verify file format is correct&lt;br&gt;3. Try processing smaller data sets |&#10;| **RCA003** | Data validation failed | Passenger records contain invalid or missing information | 1. Check source data quality&lt;br&gt;2. Review warnings list for specific issues&lt;br&gt;3. Fix data at source if possible |&#10;| **RCA004** | Excel export failed | Cannot generate or save the analysis report | 1. Check available disk space&lt;br&gt;2. Ensure output directory is writable&lt;br&gt;3. Close Excel if it's open and try again |&#10;| **RCA005** | Memory allocation error | Insufficient memory to process the dataset | 1. Close other applications&lt;br&gt;2. Process smaller data sets&lt;br&gt;3. Consider increasing system memory |&#10;&#10;### B.4 Flight Number Validation Rules&#10;&#10;**Valid Flight Number Formats:**&#10;- Minimum 3 characters, maximum 8 characters&#10;- Can contain letters, numbers, and the + symbol&#10;- Examples: `WF123`, `AI101`, `6E2024`, `SG+8475`&#10;&#10;**Important Notes:**&#10;- **Log Extractor**: Accepts + symbol between carrier code and flight number (e.g., `SG+8475`)&#10;- **Log Parser/RCA Engine**: Flight numbers should follow standard airline format&#10;- Not case-sensitive (`wf123` works same as `WF123`)&#10;&#10;### B.5 Troubleshooting Quick Reference&#10;&#10;**Most Common Issues:**&#10;&#10;1. **&quot;Azure configuration missing&quot; (LE001)**&#10;   - **Solution**: Click ⚙ Configure Azure → Enter organization, project, token → Save&#10;&#10;2. **&quot;No EDIFACT messages found&quot; (LP002)**&#10;   - **Solution**: Try switching data type (API ↔ PNR) → Verify flight number/date&#10;&#10;3. **&quot;No passenger files found&quot; (RCA001)**&#10;   - **Solution**: Use Log Parser Engine first → Select correct folder structure&#10;&#10;4. **&quot;Pipeline trigger failed&quot; (LE003)**&#10;   - **Solution**: Check flight date accuracy → Verify Azure connection → Retry&#10;&#10;5. **&quot;Multi-node consolidation error&quot; (LP004)**&#10;   - **Solution**: Turn OFF multi-node mode → Or ensure n1/, n2/, n3/ folders exist&#10;&#10;### B.6 Getting Additional Help&#10;&#10;If you encounter errors not covered in this guide:&#10;&#10;1. **Check the application log area** - Look for detailed error messages&#10;2. **Try the suggested resolution steps** - Follow the specific guidance for your error code&#10;3. **Contact your team lead** - For Azure DevOps access or configuration issues&#10;4. **Contact development team** - For persistent technical issues or unknown error codes&#10;&#10;**When reporting issues, include:**&#10;- The exact error code (e.g., LE003, LP002)&#10;- What you were trying to do when the error occurred&#10;- Flight number and date you were investigating&#10;- Any additional error messages from the application log area&#10;&#10;---&#10;&#10;**Document Version:** 3.2.0.0  &#10;**Last Updated:** November 25, 2024  &#10;**Contact:** L3 Engine Development Team" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pom_fixed.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pom_fixed.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&#10;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#10;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&#10;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#10;&#10;    &lt;groupId&gt;com.l3&lt;/groupId&gt;&#10;    &lt;artifactId&gt;engine&lt;/artifactId&gt;&#10;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&#10;    &lt;name&gt;L3 Engine&lt;/name&gt;&#10;&#10;    &lt;properties&gt;&#10;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&#10;        &lt;junit.version&gt;5.10.2&lt;/junit.version&gt;&#10;        &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;&#10;        &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;&#10;        &lt;javafx.version&gt;21&lt;/javafx.version&gt;&#10;    &lt;/properties&gt;&#10;&#10;    &lt;dependencies&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;&#10;            &lt;artifactId&gt;javafx-controls&lt;/artifactId&gt;&#10;            &lt;version&gt;21&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.openjfx&lt;/groupId&gt;&#10;            &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;&#10;            &lt;version&gt;21&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Apache POI for Excel generation --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi&lt;/artifactId&gt;&#10;            &lt;version&gt;5.2.5&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&#10;            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&#10;            &lt;version&gt;5.2.5&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;!-- Log4j2 core implementation to fix logging warning --&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;&#10;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;&#10;            &lt;version&gt;2.21.1&lt;/version&gt;&#10;        &lt;/dependency&gt;&#10;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;&#10;            &lt;version&gt;${junit.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&#10;            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;&#10;            &lt;version&gt;${junit.version}&lt;/version&gt;&#10;            &lt;scope&gt;test&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;        &lt;dependency&gt;&#10;            &lt;groupId&gt;org.testng&lt;/groupId&gt;&#10;            &lt;artifactId&gt;testng&lt;/artifactId&gt;&#10;            &lt;version&gt;7.5&lt;/version&gt;&#10;            &lt;scope&gt;compile&lt;/scope&gt;&#10;        &lt;/dependency&gt;&#10;    &lt;/dependencies&gt;&#10;&#10;    &lt;build&gt;&#10;        &lt;plugins&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.13.0&lt;/version&gt;&#10;                &lt;configuration&gt;&#10;                    &lt;source&gt;21&lt;/source&gt;&#10;                    &lt;target&gt;21&lt;/target&gt;&#10;                &lt;/configuration&gt;&#10;            &lt;/plugin&gt;&#10;            &#10;            &lt;!-- Maven Shade Plugin for creating executable JAR --&gt;&#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#10;                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;3.5.1&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;phase&gt;package&lt;/phase&gt;&#10;                        &lt;goals&gt;&#10;                            &lt;goal&gt;shade&lt;/goal&gt;&#10;                        &lt;/goals&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;transformers&gt;&#10;                                &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;&#10;                                    &lt;mainClass&gt;com.l3.apipnrengine.controller.MainApp&lt;/mainClass&gt;&#10;                                &lt;/transformer&gt;&#10;                            &lt;/transformers&gt;&#10;                            &lt;filters&gt;&#10;                                &lt;filter&gt;&#10;                                    &lt;artifact&gt;*:*&lt;/artifact&gt;&#10;                                    &lt;excludes&gt;&#10;                                        &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;&#10;                                        &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;&#10;                                        &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;&#10;                                    &lt;/excludes&gt;&#10;                                &lt;/filter&gt;&#10;                            &lt;/filters&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;            &#10;            &lt;plugin&gt;&#10;                &lt;groupId&gt;org.openjfx&lt;/groupId&gt;&#10;                &lt;artifactId&gt;javafx-maven-plugin&lt;/artifactId&gt;&#10;                &lt;version&gt;0.0.8&lt;/version&gt;&#10;                &lt;executions&gt;&#10;                    &lt;execution&gt;&#10;                        &lt;!-- Default configuration for running with: mvn clean javafx:run --&gt;&#10;                        &lt;id&gt;default-cli&lt;/id&gt;&#10;                        &lt;configuration&gt;&#10;                            &lt;mainClass&gt;com.l3.apipnrengine.controller.MainApp&lt;/mainClass&gt;&#10;                            &lt;launcher&gt;app&lt;/launcher&gt;&#10;                            &lt;jlinkZipName&gt;app&lt;/jlinkZipName&gt;&#10;                            &lt;jlinkImageName&gt;app&lt;/jlinkImageName&gt;&#10;                            &lt;noManPages&gt;true&lt;/noManPages&gt;&#10;                            &lt;stripDebug&gt;true&lt;/stripDebug&gt;&#10;                            &lt;noHeaderFiles&gt;true&lt;/noHeaderFiles&gt;&#10;                        &lt;/configuration&gt;&#10;                    &lt;/execution&gt;&#10;                &lt;/executions&gt;&#10;            &lt;/plugin&gt;&#10;        &lt;/plugins&gt;&#10;    &lt;/build&gt;&#10;&lt;/project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/config/AdvancedParserConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/config/AdvancedParserConfig.java" />
              <option name="originalContent" value="package com.l3.logparser.config;&#10;&#10;import com.l3.common.util.PropertiesUtil;&#10;&#10;import java.io.*;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.*;&#10;&#10;/**&#10; * Advanced configuration for EDIFACT message pattern matching and segment codes&#10; * Allows users to customize how messages are detected and parsed&#10; */&#10;public class AdvancedParserConfig {&#10;&#10;    // API Configuration&#10;    private ApiPatternConfig apiConfig;&#10;&#10;    // PNR Configuration (for future implementation)&#10;    private PnrPatternConfig pnrConfig;&#10;&#10;    public AdvancedParserConfig() {&#10;        loadDefaultConfiguration();&#10;        loadFromFile();&#10;    }&#10;&#10;    /**&#10;     * Load default hardcoded values from application.properties&#10;     */&#10;    private void loadDefaultConfiguration() {&#10;        this.apiConfig = new ApiPatternConfig();&#10;        this.pnrConfig = new PnrPatternConfig();&#10;&#10;        // Load default API patterns from properties&#10;        apiConfig.loadDefaults();&#10;&#10;        // PNR patterns will be added later&#10;        pnrConfig.loadDefaults();&#10;    }&#10;&#10;    /**&#10;     * Load configuration from user config file&#10;     */&#10;    public void loadFromFile() {&#10;        try {&#10;            Path configFile = getConfigFilePath();&#10;            if (!Files.exists(configFile)) {&#10;                return; // Use default values if file doesn't exist&#10;            }&#10;&#10;            Properties props = new Properties();&#10;            try (FileInputStream fis = new FileInputStream(configFile.toFile())) {&#10;                props.load(fis);&#10;            }&#10;&#10;            // Load API configuration&#10;            apiConfig.loadFromProperties(props);&#10;&#10;            // Load PNR configuration (when implemented)&#10;            // pnrConfig.loadFromProperties(props);&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Warning: Could not load advanced parser configuration: &quot; + e.getMessage());&#10;            // Continue with default values&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Save configuration to properties file&#10;     */&#10;    public boolean saveToFile() {&#10;        try {&#10;            Path configFile = getConfigFilePath();&#10;&#10;            // Create directory if it doesn't exist&#10;            Files.createDirectories(configFile.getParent());&#10;&#10;            Properties props = new Properties();&#10;&#10;            // Save API configuration&#10;            apiConfig.saveToProperties(props);&#10;&#10;            // Save PNR configuration (when implemented)&#10;            // pnrConfig.saveToProperties(props);&#10;&#10;            // Save to file with comments&#10;            try (FileOutputStream fos = new FileOutputStream(configFile.toFile())) {&#10;                props.store(fos, &quot;L3 Engine - Advanced Parser Configuration\nGenerated on: &quot; + new java.util.Date());&#10;            }&#10;&#10;            return true;&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error: Could not save advanced parser configuration: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get the path to the configuration file&#10;     */&#10;    private Path getConfigFilePath() {&#10;        String userHome = System.getProperty(&quot;user.home&quot;);&#10;        return Paths.get(userHome, &quot;.l3engine&quot;, &quot;parser-config.properties&quot;);&#10;    }&#10;&#10;    /**&#10;     * Check if configuration file exists&#10;     */&#10;    public boolean configFileExists() {&#10;        return Files.exists(getConfigFilePath());&#10;    }&#10;&#10;    // Getters and Setters&#10;    public ApiPatternConfig getApiConfig() {&#10;        return apiConfig;&#10;    }&#10;&#10;    public void setApiConfig(ApiPatternConfig apiConfig) {&#10;        this.apiConfig = apiConfig;&#10;    }&#10;&#10;    public PnrPatternConfig getPnrConfig() {&#10;        return pnrConfig;&#10;    }&#10;&#10;    public void setPnrConfig(PnrPatternConfig pnrConfig) {&#10;        this.pnrConfig = pnrConfig;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.l3.logparser.config;&#13;&#10;&#13;&#10;import com.l3.common.util.PropertiesUtil;&#13;&#10;&#13;&#10;import java.io.*;&#13;&#10;import java.nio.file.Files;&#13;&#10;import java.nio.file.Path;&#13;&#10;import java.nio.file.Paths;&#13;&#10;import java.util.*;&#13;&#10;&#13;&#10;/**&#13;&#10; * Advanced configuration for EDIFACT message pattern matching and segment codes&#13;&#10; * Allows users to customize how messages are detected and parsed&#13;&#10; */&#13;&#10;public class AdvancedParserConfig {&#13;&#10;&#13;&#10;    // API Configuration&#13;&#10;    private ApiPatternConfig apiConfig;&#13;&#10;&#13;&#10;    // PNR Configuration (for future implementation)&#13;&#10;    private PnrPatternConfig pnrConfig;&#13;&#10;&#13;&#10;    public AdvancedParserConfig() {&#13;&#10;        loadDefaultConfiguration();&#13;&#10;        loadFromFile();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#10;     * Load default hardcoded values from application.properties&#10;     */&#10;    private void loadDefaultConfiguration() {&#10;        this.apiConfig = new ApiPatternConfig();&#10;        this.pnrConfig = new PnrPatternConfig();&#10;&#10;        // Load default API patterns from properties&#10;        apiConfig.loadDefaults();&#10;&#10;        // PNR patterns will be added later&#10;        pnrConfig.loadDefaults();&#10;    }&#10;&#10;    /**&#10;     * Reset configuration to default values only (without loading from file)&#10;     */&#10;    public void resetToDefaults() {&#10;        loadDefaultConfiguration();&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Load configuration from user config file&#13;&#10;     */&#13;&#10;    public void loadFromFile() {&#13;&#10;        try {&#13;&#10;            Path configFile = getConfigFilePath();&#13;&#10;            if (!Files.exists(configFile)) {&#13;&#10;                return; // Use default values if file doesn't exist&#13;&#10;            }&#13;&#10;&#13;&#10;            Properties props = new Properties();&#13;&#10;            try (FileInputStream fis = new FileInputStream(configFile.toFile())) {&#13;&#10;                props.load(fis);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Load API configuration&#13;&#10;            apiConfig.loadFromProperties(props);&#13;&#10;&#13;&#10;            // Load PNR configuration (when implemented)&#13;&#10;            // pnrConfig.loadFromProperties(props);&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            System.err.println(&quot;Warning: Could not load advanced parser configuration: &quot; + e.getMessage());&#13;&#10;            // Continue with default values&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Save configuration to properties file&#13;&#10;     */&#13;&#10;    public boolean saveToFile() {&#13;&#10;        try {&#13;&#10;            Path configFile = getConfigFilePath();&#13;&#10;&#13;&#10;            // Create directory if it doesn't exist&#13;&#10;            Files.createDirectories(configFile.getParent());&#13;&#10;&#13;&#10;            Properties props = new Properties();&#13;&#10;&#13;&#10;            // Save API configuration&#13;&#10;            apiConfig.saveToProperties(props);&#13;&#10;&#13;&#10;            // Save PNR configuration (when implemented)&#13;&#10;            // pnrConfig.saveToProperties(props);&#13;&#10;&#13;&#10;            // Save to file with comments&#13;&#10;            try (FileOutputStream fos = new FileOutputStream(configFile.toFile())) {&#13;&#10;                props.store(fos, &quot;L3 Engine - Advanced Parser Configuration\nGenerated on: &quot; + new java.util.Date());&#13;&#10;            }&#13;&#10;&#13;&#10;            return true;&#13;&#10;&#13;&#10;        } catch (Exception e) {&#13;&#10;            System.err.println(&quot;Error: Could not save advanced parser configuration: &quot; + e.getMessage());&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Get the path to the configuration file&#13;&#10;     */&#13;&#10;    private Path getConfigFilePath() {&#13;&#10;        String userHome = System.getProperty(&quot;user.home&quot;);&#13;&#10;        return Paths.get(userHome, &quot;.l3engine&quot;, &quot;parser-config.properties&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Check if configuration file exists&#13;&#10;     */&#13;&#10;    public boolean configFileExists() {&#13;&#10;        return Files.exists(getConfigFilePath());&#13;&#10;    }&#13;&#10;&#13;&#10;    // Getters and Setters&#13;&#10;    public ApiPatternConfig getApiConfig() {&#13;&#10;        return apiConfig;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setApiConfig(ApiPatternConfig apiConfig) {&#13;&#10;        this.apiConfig = apiConfig;&#13;&#10;    }&#13;&#10;&#13;&#10;    public PnrPatternConfig getPnrConfig() {&#13;&#10;        return pnrConfig;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setPnrConfig(PnrPatternConfig pnrConfig) {&#13;&#10;        this.pnrConfig = pnrConfig;&#13;&#10;    }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/controller/AdvancedConfigController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/controller/AdvancedConfigController.java" />
              <option name="originalContent" value="package com.l3.logparser.controller;&#10;&#10;import com.l3.logparser.config.AdvancedParserConfig;&#10;import com.l3.logparser.config.ApiPatternConfig;&#10;import javafx.beans.property.SimpleStringProperty;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.Initializable;&#10;import javafx.scene.control.*;&#10;import javafx.scene.control.cell.PropertyValueFactory;&#10;import javafx.scene.control.cell.TextFieldTableCell;&#10;import javafx.stage.Stage;&#10;import javafx.util.converter.BooleanStringConverter;&#10;&#10;import java.net.URL;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.ResourceBundle;&#10;&#10;/**&#10; * Controller for the Advanced Configuration Dialog&#10; */&#10;public class AdvancedConfigController implements Initializable {&#10;&#10;    // Pattern Management&#10;    @FXML private TableView&lt;PatternTableRow&gt; patternsTable;&#10;    @FXML private TableColumn&lt;PatternTableRow, String&gt; patternNameColumn;&#10;    @FXML private TableColumn&lt;PatternTableRow, String&gt; patternTypeColumn;&#10;    @FXML private TableColumn&lt;PatternTableRow, String&gt; patternValueColumn;&#10;    @FXML private TableColumn&lt;PatternTableRow, Boolean&gt; patternEnabledColumn;&#10;    @FXML private Button addPatternButton;&#10;    @FXML private Button removePatternButton;&#10;    @FXML private Button editPatternButton;&#10;&#10;    // Segment Codes&#10;    @FXML private TextField bgmPassengerField;&#10;    @FXML private TextField bgmCrewField;&#10;    @FXML private TextField locDepartureField;&#10;    @FXML private TextField locArrivalField;&#10;    @FXML private TextField dtmDepartureField;&#10;    @FXML private TextField dtmArrivalField;&#10;    @FXML private TextField tdtFlightPositionField;&#10;&#10;    // Dialog controls&#10;    @FXML private Button saveButton;&#10;    @FXML private Button cancelButton;&#10;    @FXML private Button resetButton;&#10;&#10;    private AdvancedParserConfig config;&#10;    private ObservableList&lt;PatternTableRow&gt; patternData;&#10;    private boolean saved = false;&#10;    private Stage dialogStage;&#10;&#10;    @Override&#10;    public void initialize(URL location, ResourceBundle resources) {&#10;        setupPatternsTable();&#10;        this.config = new AdvancedParserConfig();&#10;        loadConfigurationData();&#10;    }&#10;&#10;    public void setConfig(AdvancedParserConfig config) {&#10;        this.config = config;&#10;        loadConfigurationData();&#10;    }&#10;&#10;    public void setDialogStage(Stage dialogStage) {&#10;        this.dialogStage = dialogStage;&#10;    }&#10;&#10;    public boolean isSaved() {&#10;        return saved;&#10;    }&#10;&#10;    public AdvancedParserConfig getConfig() {&#10;        return config;&#10;    }&#10;&#10;    private void setupPatternsTable() {&#10;        patternData = FXCollections.observableArrayList();&#10;        patternsTable.setItems(patternData);&#10;&#10;        // Configure columns&#10;        patternNameColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;name&quot;));&#10;        patternNameColumn.setCellFactory(TextFieldTableCell.forTableColumn());&#10;        patternNameColumn.setOnEditCommit(event -&gt; {&#10;            PatternTableRow row = event.getRowValue();&#10;            row.setName(event.getNewValue());&#10;        });&#10;&#10;        patternTypeColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;type&quot;));&#10;        patternValueColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;value&quot;));&#10;&#10;        patternEnabledColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;enabled&quot;));&#10;        patternEnabledColumn.setCellFactory(col -&gt; {&#10;            TableCell&lt;PatternTableRow, Boolean&gt; cell = new TableCell&lt;PatternTableRow, Boolean&gt;() {&#10;                private final CheckBox checkBox = new CheckBox();&#10;&#10;                {&#10;                    checkBox.setOnAction(event -&gt; {&#10;                        PatternTableRow row = getTableRow().getItem();&#10;                        if (row != null) {&#10;                            row.setEnabled(checkBox.isSelected());&#10;                        }&#10;                    });&#10;                }&#10;&#10;                @Override&#10;                protected void updateItem(Boolean item, boolean empty) {&#10;                    super.updateItem(item, empty);&#10;                    if (empty) {&#10;                        setGraphic(null);&#10;                    } else {&#10;                        checkBox.setSelected(item != null &amp;&amp; item);&#10;                        setGraphic(checkBox);&#10;                    }&#10;                }&#10;            };&#10;            return cell;&#10;        });&#10;&#10;        // Enable table editing&#10;        patternsTable.setEditable(true);&#10;    }&#10;&#10;    private void loadConfigurationData() {&#10;        // Load patterns&#10;        patternData.clear();&#10;        List&lt;ApiPatternConfig.MessagePattern&gt; patterns = config.getApiConfig().getMessageStartPatterns();&#10;        for (ApiPatternConfig.MessagePattern pattern : patterns) {&#10;            patternData.add(new PatternTableRow(pattern));&#10;        }&#10;&#10;        // Load segment codes&#10;        ApiPatternConfig.SegmentCodes codes = config.getApiConfig().getSegmentCodes();&#10;        bgmPassengerField.setText(codes.getBgmPassengerCode());&#10;        bgmCrewField.setText(codes.getBgmCrewCode());&#10;        locDepartureField.setText(codes.getLocDepartureCode());&#10;        locArrivalField.setText(codes.getLocArrivalCode());&#10;        dtmDepartureField.setText(codes.getDtmDepartureCode());&#10;        dtmArrivalField.setText(codes.getDtmArrivalCode());&#10;        tdtFlightPositionField.setText(String.valueOf(codes.getTdtFlightPosition()));&#10;    }&#10;&#10;    @FXML&#10;    private void onAddPattern() {&#10;        PatternEditDialog dialog = new PatternEditDialog(null);&#10;        dialog.showAndWait().ifPresent(pattern -&gt; {&#10;            patternData.add(new PatternTableRow(pattern));&#10;        });&#10;    }&#10;&#10;    @FXML&#10;    private void onRemovePattern() {&#10;        PatternTableRow selected = patternsTable.getSelectionModel().getSelectedItem();&#10;        if (selected != null) {&#10;            patternData.remove(selected);&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onEditPattern() {&#10;        PatternTableRow selected = patternsTable.getSelectionModel().getSelectedItem();&#10;        if (selected != null) {&#10;            PatternEditDialog dialog = new PatternEditDialog(selected.toMessagePattern());&#10;            dialog.showAndWait().ifPresent(pattern -&gt; {&#10;                selected.updateFromPattern(pattern);&#10;                patternsTable.refresh();&#10;            });&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onSave() {&#10;        if (saveConfiguration()) {&#10;            saved = true;&#10;            dialogStage.close();&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onCancel() {&#10;        saved = false;&#10;        dialogStage.close();&#10;    }&#10;&#10;    @FXML&#10;    private void onReset() {&#10;        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);&#10;        alert.setTitle(&quot;Reset Configuration&quot;);&#10;        alert.setHeaderText(&quot;Reset to Default Values&quot;);&#10;        alert.setContentText(&quot;Are you sure you want to reset all configuration to default values?&quot;);&#10;&#10;        alert.showAndWait().ifPresent(response -&gt; {&#10;            if (response == ButtonType.OK) {&#10;                config = new AdvancedParserConfig();&#10;                loadConfigurationData();&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean saveConfiguration() {&#10;        try {&#10;            // Save patterns&#10;            List&lt;ApiPatternConfig.MessagePattern&gt; patterns = new ArrayList&lt;&gt;();&#10;            for (PatternTableRow row : patternData) {&#10;                patterns.add(row.toMessagePattern());&#10;            }&#10;            config.getApiConfig().setMessageStartPatterns(patterns);&#10;&#10;            // Save segment codes&#10;            ApiPatternConfig.SegmentCodes codes = config.getApiConfig().getSegmentCodes();&#10;            codes.setBgmPassengerCode(bgmPassengerField.getText());&#10;            codes.setBgmCrewCode(bgmCrewField.getText());&#10;            codes.setLocDepartureCode(locDepartureField.getText());&#10;            codes.setLocArrivalCode(locArrivalField.getText());&#10;            codes.setDtmDepartureCode(dtmDepartureField.getText());&#10;            codes.setDtmArrivalCode(dtmArrivalField.getText());&#10;&#10;            try {&#10;                int position = Integer.parseInt(tdtFlightPositionField.getText());&#10;                codes.setTdtFlightPosition(position);&#10;            } catch (NumberFormatException e) {&#10;                Alert alert = new Alert(Alert.AlertType.ERROR);&#10;                alert.setTitle(&quot;Invalid Input&quot;);&#10;                alert.setHeaderText(&quot;TDT Flight Position Error&quot;);&#10;                alert.setContentText(&quot;TDT Flight Position must be a valid number.&quot;);&#10;                alert.showAndWait();&#10;                return false;&#10;            }&#10;&#10;            // Save to file&#10;            boolean saveSuccess = config.saveToFile();&#10;            if (!saveSuccess) {&#10;                Alert alert = new Alert(Alert.AlertType.ERROR);&#10;                alert.setTitle(&quot;Save Error&quot;);&#10;                alert.setHeaderText(&quot;Configuration Save Failed&quot;);&#10;                alert.setContentText(&quot;Could not save configuration to file.&quot;);&#10;                alert.showAndWait();&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;&#10;        } catch (Exception e) {&#10;            Alert alert = new Alert(Alert.AlertType.ERROR);&#10;            alert.setTitle(&quot;Save Error&quot;);&#10;            alert.setHeaderText(&quot;Unexpected Error&quot;);&#10;            alert.setContentText(&quot;An error occurred while saving: &quot; + e.getMessage());&#10;            alert.showAndWait();&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Table row representation of a message pattern&#10;     */&#10;    public static class PatternTableRow {&#10;        private SimpleStringProperty name;&#10;        private SimpleStringProperty type;&#10;        private SimpleStringProperty value;&#10;        private boolean enabled;&#10;        private List&lt;ApiPatternConfig.MessagePattern.Condition&gt; conditions;&#10;&#10;        public PatternTableRow(ApiPatternConfig.MessagePattern pattern) {&#10;            this.name = new SimpleStringProperty(pattern.getName());&#10;            this.type = new SimpleStringProperty(pattern.getType());&#10;            this.enabled = pattern.isEnabled();&#10;            this.conditions = new ArrayList&lt;&gt;(pattern.getConditions());&#10;&#10;            String displayValue;&#10;            if (&quot;multiple&quot;.equals(pattern.getType()) &amp;&amp; pattern.getConditions() != null &amp;&amp; !pattern.getConditions().isEmpty()) {&#10;                displayValue = pattern.getConditions().size() + &quot; condition(s)&quot;;&#10;            } else {&#10;                displayValue = pattern.getValue() != null ? pattern.getValue() : &quot;&quot;;&#10;            }&#10;            this.value = new SimpleStringProperty(displayValue);&#10;        }&#10;&#10;        public void updateFromPattern(ApiPatternConfig.MessagePattern pattern) {&#10;            this.name.set(pattern.getName());&#10;            this.type.set(pattern.getType());&#10;            this.enabled = pattern.isEnabled();&#10;            this.conditions = new ArrayList&lt;&gt;(pattern.getConditions());&#10;&#10;            String displayValue;&#10;            if (&quot;multiple&quot;.equals(pattern.getType()) &amp;&amp; pattern.getConditions() != null &amp;&amp; !pattern.getConditions().isEmpty()) {&#10;                displayValue = pattern.getConditions().size() + &quot; condition(s)&quot;;&#10;            } else {&#10;                displayValue = pattern.getValue() != null ? pattern.getValue() : &quot;&quot;;&#10;            }&#10;            this.value.set(displayValue);&#10;        }&#10;&#10;        public ApiPatternConfig.MessagePattern toMessagePattern() {&#10;            ApiPatternConfig.MessagePattern pattern = new ApiPatternConfig.MessagePattern(&#10;                getName(), getType(), getValue(), isEnabled()&#10;            );&#10;            pattern.setConditions(new ArrayList&lt;&gt;(conditions));&#10;            return pattern;&#10;        }&#10;&#10;        // Property getters for table binding&#10;        public String getName() { return name.get(); }&#10;        public void setName(String name) { this.name.set(name); }&#10;        public SimpleStringProperty nameProperty() { return name; }&#10;&#10;        public String getType() { return type.get(); }&#10;        public void setType(String type) { this.type.set(type); }&#10;        public SimpleStringProperty typeProperty() { return type; }&#10;&#10;        public String getValue() { return value.get(); }&#10;        public void setValue(String value) { this.value.set(value); }&#10;        public SimpleStringProperty valueProperty() { return value; }&#10;&#10;        public boolean isEnabled() { return enabled; }&#10;        public void setEnabled(boolean enabled) { this.enabled = enabled; }&#10;&#10;        public List&lt;ApiPatternConfig.MessagePattern.Condition&gt; getConditions() { return conditions; }&#10;        public void setConditions(List&lt;ApiPatternConfig.MessagePattern.Condition&gt; conditions) { this.conditions = conditions; }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.l3.logparser.controller;&#10;&#10;import com.l3.logparser.config.AdvancedParserConfig;&#10;import com.l3.logparser.config.ApiPatternConfig;&#10;import javafx.beans.property.SimpleStringProperty;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.Initializable;&#10;import javafx.scene.control.*;&#10;import javafx.scene.control.cell.PropertyValueFactory;&#10;import javafx.scene.control.cell.TextFieldTableCell;&#10;import javafx.stage.Stage;&#10;import javafx.util.converter.BooleanStringConverter;&#10;&#10;import java.net.URL;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.ResourceBundle;&#10;&#10;/**&#10; * Controller for the Advanced Configuration Dialog&#10; */&#10;public class AdvancedConfigController implements Initializable {&#10;&#10;    // Pattern Management&#10;    @FXML private TableView&lt;PatternTableRow&gt; patternsTable;&#10;    @FXML private TableColumn&lt;PatternTableRow, String&gt; patternNameColumn;&#10;    @FXML private TableColumn&lt;PatternTableRow, String&gt; patternTypeColumn;&#10;    @FXML private TableColumn&lt;PatternTableRow, String&gt; patternValueColumn;&#10;    @FXML private TableColumn&lt;PatternTableRow, Boolean&gt; patternEnabledColumn;&#10;    @FXML private Button addPatternButton;&#10;    @FXML private Button removePatternButton;&#10;    @FXML private Button editPatternButton;&#10;&#10;    // Segment Codes&#10;    @FXML private TextField bgmPassengerField;&#10;    @FXML private TextField bgmCrewField;&#10;    @FXML private TextField locDepartureField;&#10;    @FXML private TextField locArrivalField;&#10;    @FXML private TextField dtmDepartureField;&#10;    @FXML private TextField dtmArrivalField;&#10;    @FXML private TextField tdtFlightPositionField;&#10;&#10;    // Dialog controls&#10;    @FXML private Button saveButton;&#10;    @FXML private Button cancelButton;&#10;    @FXML private Button resetButton;&#10;&#10;    private AdvancedParserConfig config;&#10;    private ObservableList&lt;PatternTableRow&gt; patternData;&#10;    private boolean saved = false;&#10;    private Stage dialogStage;&#10;&#10;    @Override&#10;    public void initialize(URL location, ResourceBundle resources) {&#10;        setupPatternsTable();&#10;        this.config = new AdvancedParserConfig();&#10;        loadConfigurationData();&#10;    }&#10;&#10;    public void setConfig(AdvancedParserConfig config) {&#10;        this.config = config;&#10;        loadConfigurationData();&#10;    }&#10;&#10;    public void setDialogStage(Stage dialogStage) {&#10;        this.dialogStage = dialogStage;&#10;    }&#10;&#10;    public boolean isSaved() {&#10;        return saved;&#10;    }&#10;&#10;    public AdvancedParserConfig getConfig() {&#10;        return config;&#10;    }&#10;&#10;    private void setupPatternsTable() {&#10;        patternData = FXCollections.observableArrayList();&#10;        patternsTable.setItems(patternData);&#10;&#10;        // Configure columns&#10;        patternNameColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;name&quot;));&#10;        patternNameColumn.setCellFactory(TextFieldTableCell.forTableColumn());&#10;        patternNameColumn.setOnEditCommit(event -&gt; {&#10;            PatternTableRow row = event.getRowValue();&#10;            row.setName(event.getNewValue());&#10;        });&#10;&#10;        patternTypeColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;type&quot;));&#10;        patternValueColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;value&quot;));&#10;&#10;        patternEnabledColumn.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;enabled&quot;));&#10;        patternEnabledColumn.setCellFactory(col -&gt; {&#10;            TableCell&lt;PatternTableRow, Boolean&gt; cell = new TableCell&lt;PatternTableRow, Boolean&gt;() {&#10;                private final CheckBox checkBox = new CheckBox();&#10;&#10;                {&#10;                    checkBox.setOnAction(event -&gt; {&#10;                        PatternTableRow row = getTableRow().getItem();&#10;                        if (row != null) {&#10;                            row.setEnabled(checkBox.isSelected());&#10;                        }&#10;                    });&#10;                }&#10;&#10;                @Override&#10;                protected void updateItem(Boolean item, boolean empty) {&#10;                    super.updateItem(item, empty);&#10;                    if (empty) {&#10;                        setGraphic(null);&#10;                    } else {&#10;                        checkBox.setSelected(item != null &amp;&amp; item);&#10;                        setGraphic(checkBox);&#10;                    }&#10;                }&#10;            };&#10;            return cell;&#10;        });&#10;&#10;        // Enable table editing&#10;        patternsTable.setEditable(true);&#10;    }&#10;&#10;    private void loadConfigurationData() {&#10;        // Load patterns&#10;        patternData.clear();&#10;        List&lt;ApiPatternConfig.MessagePattern&gt; patterns = config.getApiConfig().getMessageStartPatterns();&#10;        for (ApiPatternConfig.MessagePattern pattern : patterns) {&#10;            patternData.add(new PatternTableRow(pattern));&#10;        }&#10;&#10;        // Load segment codes&#10;        ApiPatternConfig.SegmentCodes codes = config.getApiConfig().getSegmentCodes();&#10;        bgmPassengerField.setText(codes.getBgmPassengerCode());&#10;        bgmCrewField.setText(codes.getBgmCrewCode());&#10;        locDepartureField.setText(codes.getLocDepartureCode());&#10;        locArrivalField.setText(codes.getLocArrivalCode());&#10;        dtmDepartureField.setText(codes.getDtmDepartureCode());&#10;        dtmArrivalField.setText(codes.getDtmArrivalCode());&#10;        tdtFlightPositionField.setText(String.valueOf(codes.getTdtFlightPosition()));&#10;    }&#10;&#10;    @FXML&#10;    private void onAddPattern() {&#10;        PatternEditDialog dialog = new PatternEditDialog(null);&#10;        dialog.showAndWait().ifPresent(pattern -&gt; {&#10;            patternData.add(new PatternTableRow(pattern));&#10;        });&#10;    }&#10;&#10;    @FXML&#10;    private void onRemovePattern() {&#10;        PatternTableRow selected = patternsTable.getSelectionModel().getSelectedItem();&#10;        if (selected != null) {&#10;            patternData.remove(selected);&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onEditPattern() {&#10;        PatternTableRow selected = patternsTable.getSelectionModel().getSelectedItem();&#10;        if (selected != null) {&#10;            PatternEditDialog dialog = new PatternEditDialog(selected.toMessagePattern());&#10;            dialog.showAndWait().ifPresent(pattern -&gt; {&#10;                selected.updateFromPattern(pattern);&#10;                patternsTable.refresh();&#10;            });&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onSave() {&#10;        if (saveConfiguration()) {&#10;            saved = true;&#10;            dialogStage.close();&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onCancel() {&#10;        saved = false;&#10;        dialogStage.close();&#10;    }&#10;&#10;    @FXML&#10;    private void onReset() {&#10;        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);&#10;        alert.setTitle(&quot;Reset Configuration&quot;);&#10;        alert.setHeaderText(&quot;Reset to Default Values&quot;);&#10;        alert.setContentText(&quot;Are you sure you want to reset all configuration to default values?&quot;);&#10;&#10;        alert.showAndWait().ifPresent(response -&gt; {&#10;            if (response == ButtonType.OK) {&#10;                config.resetToDefaults();&#10;                loadConfigurationData();&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean saveConfiguration() {&#10;        try {&#10;            // Save patterns&#10;            List&lt;ApiPatternConfig.MessagePattern&gt; patterns = new ArrayList&lt;&gt;();&#10;            for (PatternTableRow row : patternData) {&#10;                patterns.add(row.toMessagePattern());&#10;            }&#10;            config.getApiConfig().setMessageStartPatterns(patterns);&#10;&#10;            // Save segment codes&#10;            ApiPatternConfig.SegmentCodes codes = config.getApiConfig().getSegmentCodes();&#10;            codes.setBgmPassengerCode(bgmPassengerField.getText());&#10;            codes.setBgmCrewCode(bgmCrewField.getText());&#10;            codes.setLocDepartureCode(locDepartureField.getText());&#10;            codes.setLocArrivalCode(locArrivalField.getText());&#10;            codes.setDtmDepartureCode(dtmDepartureField.getText());&#10;            codes.setDtmArrivalCode(dtmArrivalField.getText());&#10;&#10;            try {&#10;                int position = Integer.parseInt(tdtFlightPositionField.getText());&#10;                codes.setTdtFlightPosition(position);&#10;            } catch (NumberFormatException e) {&#10;                Alert alert = new Alert(Alert.AlertType.ERROR);&#10;                alert.setTitle(&quot;Invalid Input&quot;);&#10;                alert.setHeaderText(&quot;TDT Flight Position Error&quot;);&#10;                alert.setContentText(&quot;TDT Flight Position must be a valid number.&quot;);&#10;                alert.showAndWait();&#10;                return false;&#10;            }&#10;&#10;            // Save to file&#10;            boolean saveSuccess = config.saveToFile();&#10;            if (!saveSuccess) {&#10;                Alert alert = new Alert(Alert.AlertType.ERROR);&#10;                alert.setTitle(&quot;Save Error&quot;);&#10;                alert.setHeaderText(&quot;Configuration Save Failed&quot;);&#10;                alert.setContentText(&quot;Could not save configuration to file.&quot;);&#10;                alert.showAndWait();&#10;                return false;&#10;            }&#10;&#10;            return true;&#10;&#10;        } catch (Exception e) {&#10;            Alert alert = new Alert(Alert.AlertType.ERROR);&#10;            alert.setTitle(&quot;Save Error&quot;);&#10;            alert.setHeaderText(&quot;Unexpected Error&quot;);&#10;            alert.setContentText(&quot;An error occurred while saving: &quot; + e.getMessage());&#10;            alert.showAndWait();&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Table row representation of a message pattern&#10;     */&#10;    public static class PatternTableRow {&#10;        private SimpleStringProperty name;&#10;        private SimpleStringProperty type;&#10;        private SimpleStringProperty value;&#10;        private boolean enabled;&#10;        private List&lt;ApiPatternConfig.MessagePattern.Condition&gt; conditions;&#10;&#10;        public PatternTableRow(ApiPatternConfig.MessagePattern pattern) {&#10;            this.name = new SimpleStringProperty(pattern.getName());&#10;            this.type = new SimpleStringProperty(pattern.getType());&#10;            this.enabled = pattern.isEnabled();&#10;            this.conditions = new ArrayList&lt;&gt;(pattern.getConditions());&#10;&#10;            String displayValue;&#10;            if (&quot;multiple&quot;.equals(pattern.getType()) &amp;&amp; pattern.getConditions() != null &amp;&amp; !pattern.getConditions().isEmpty()) {&#10;                displayValue = pattern.getConditions().size() + &quot; condition(s)&quot;;&#10;            } else {&#10;                displayValue = pattern.getValue() != null ? pattern.getValue() : &quot;&quot;;&#10;            }&#10;            this.value = new SimpleStringProperty(displayValue);&#10;        }&#10;&#10;        public void updateFromPattern(ApiPatternConfig.MessagePattern pattern) {&#10;            this.name.set(pattern.getName());&#10;            this.type.set(pattern.getType());&#10;            this.enabled = pattern.isEnabled();&#10;            this.conditions = new ArrayList&lt;&gt;(pattern.getConditions());&#10;&#10;            String displayValue;&#10;            if (&quot;multiple&quot;.equals(pattern.getType()) &amp;&amp; pattern.getConditions() != null &amp;&amp; !pattern.getConditions().isEmpty()) {&#10;                displayValue = pattern.getConditions().size() + &quot; condition(s)&quot;;&#10;            } else {&#10;                displayValue = pattern.getValue() != null ? pattern.getValue() : &quot;&quot;;&#10;            }&#10;            this.value.set(displayValue);&#10;        }&#10;&#10;        public ApiPatternConfig.MessagePattern toMessagePattern() {&#10;            ApiPatternConfig.MessagePattern pattern = new ApiPatternConfig.MessagePattern(&#10;                getName(), getType(), getValue(), isEnabled()&#10;            );&#10;            pattern.setConditions(new ArrayList&lt;&gt;(conditions));&#10;            return pattern;&#10;        }&#10;&#10;        // Property getters for table binding&#10;        public String getName() { return name.get(); }&#10;        public void setName(String name) { this.name.set(name); }&#10;        public SimpleStringProperty nameProperty() { return name; }&#10;&#10;        public String getType() { return type.get(); }&#10;        public void setType(String type) { this.type.set(type); }&#10;        public SimpleStringProperty typeProperty() { return type; }&#10;&#10;        public String getValue() { return value.get(); }&#10;        public void setValue(String value) { this.value.set(value); }&#10;        public SimpleStringProperty valueProperty() { return value; }&#10;&#10;        public boolean isEnabled() { return enabled; }&#10;        public void setEnabled(boolean enabled) { this.enabled = enabled; }&#10;&#10;        public List&lt;ApiPatternConfig.MessagePattern.Condition&gt; getConditions() { return conditions; }&#10;        public void setConditions(List&lt;ApiPatternConfig.MessagePattern.Condition&gt; conditions) { this.conditions = conditions; }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/controller/PnrExtractionController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/controller/PnrExtractionController.java" />
              <option name="updatedContent" value="package com.l3.logparser.pnr.controller;&#10;&#10;import com.l3.logparser.pnr.model.PnrMessage;&#10;import com.l3.logparser.pnr.service.PnrExtractionService;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.Initializable;&#10;import javafx.scene.control.*;&#10;&#10;import java.net.URL;&#10;import java.util.ResourceBundle;&#10;&#10;/**&#10; * Controller for PNR extraction functionality&#10; * This will be developed independently from the API controller&#10; */&#10;public class PnrExtractionController implements Initializable {&#10;    &#10;    @FXML private TextField logDirectoryField;&#10;    @FXML private TextField flightNumberField;&#10;    @FXML private TextField pnrReferenceField;&#10;    @FXML private Button processButton;&#10;    @FXML private TableView&lt;PnrMessage&gt; resultsTable;&#10;    @FXML private TextArea logArea;&#10;    &#10;    private PnrExtractionService pnrExtractionService;&#10;    &#10;    @Override&#10;    public void initialize(URL location, ResourceBundle resources) {&#10;        pnrExtractionService = new PnrExtractionService();&#10;        setupUI();&#10;        // TODO: Setup table columns for PNR-specific data&#10;    }&#10;    &#10;    private void setupUI() {&#10;        // TODO: Initialize PNR-specific UI components&#10;        pnrReferenceField.setPromptText(&quot;e.g., ABC123&quot;);&#10;        flightNumberField.setPromptText(&quot;e.g., MS775&quot;);&#10;    }&#10;    &#10;    @FXML&#10;    private void onProcessPnrLogs() {&#10;        // TODO: Implement PNR log processing&#10;        String logDirectory = logDirectoryField.getText().trim();&#10;        String flightNumber = flightNumberField.getText().trim();&#10;        String pnrReference = pnrReferenceField.getText().trim();&#10;        &#10;        if (logDirectory.isEmpty()) {&#10;            showAlert(&quot;Error&quot;, &quot;Please select a log directory&quot;);&#10;            return;&#10;        }&#10;        &#10;        // TODO: Create background task for PNR extraction&#10;    }&#10;    &#10;    private void showAlert(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/model/PnrDetails.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/model/PnrDetails.java" />
              <option name="updatedContent" value="package com.l3.logparser.pnr.model;&#10;&#10;/**&#10; * Model representing PNR-specific details extracted from logs&#10; */&#10;public class PnrDetails {&#10;    private String pnrReference;&#10;    private String bookingDate;&#10;    private String passengerCount;&#10;    private String flightDetails;&#10;    private String bookingStatus;&#10;    &#10;    public PnrDetails() {}&#10;    &#10;    // Getters and Setters&#10;    public String getPnrReference() { return pnrReference; }&#10;    public void setPnrReference(String pnrReference) { this.pnrReference = pnrReference; }&#10;    &#10;    public String getBookingDate() { return bookingDate; }&#10;    public void setBookingDate(String bookingDate) { this.bookingDate = bookingDate; }&#10;    &#10;    public String getPassengerCount() { return passengerCount; }&#10;    public void setPassengerCount(String passengerCount) { this.passengerCount = passengerCount; }&#10;    &#10;    public String getFlightDetails() { return flightDetails; }&#10;    public void setFlightDetails(String flightDetails) { this.flightDetails = flightDetails; }&#10;    &#10;    public String getBookingStatus() { return bookingStatus; }&#10;    public void setBookingStatus(String bookingStatus) { this.bookingStatus = bookingStatus; }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return &quot;PnrDetails{&quot; +&#10;                &quot;pnrReference='&quot; + pnrReference + '\'' +&#10;                &quot;, bookingDate='&quot; + bookingDate + '\'' +&#10;                &quot;, passengerCount='&quot; + passengerCount + '\'' +&#10;                &quot;, bookingStatus='&quot; + bookingStatus + '\'' +&#10;                '}';&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/parser/PnrParser.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/l3/logparser/pnr/parser/PnrParser.java" />
              <option name="updatedContent" value="package com.l3.logparser.pnr.parser;&#10;&#10;import com.l3.logparser.pnr.model.PnrMessage;&#10;import com.l3.logparser.pnr.model.PnrDetails;&#10;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;/**&#10; * Parser for PNR messages found in log files&#10; * Handles PNR-specific parsing logic separate from API parsing&#10; */&#10;public class PnrParser {&#10;    &#10;    /**&#10;     * Parse log content to extract PNR messages&#10;     * @param logContent The raw log file content&#10;     * @param targetFlightNumber Optional flight number filter&#10;     * @return List of extracted PNR messages&#10;     */&#10;    public List&lt;PnrMessage&gt; parseLogContent(String logContent, String targetFlightNumber) {&#10;        List&lt;PnrMessage&gt; messages = new ArrayList&lt;&gt;();&#10;        &#10;        // TODO: Implement PNR-specific parsing logic&#10;        // This will be different from API EDIFACT parsing&#10;        // PNR logs may have different formats and patterns&#10;        &#10;        return messages;&#10;    }&#10;    &#10;    /**&#10;     * Parse PNR details from a specific message format&#10;     * @param messageContent The PNR message content&#10;     * @return PnrDetails object with extracted information&#10;     */&#10;    private PnrDetails parsePnrDetails(String messageContent) {&#10;        PnrDetails details = new PnrDetails();&#10;        &#10;        // TODO: Implement PNR details extraction&#10;        // Parse booking reference, passenger info, etc.&#10;        &#10;        return details;&#10;    }&#10;    &#10;    /**&#10;     * Check if a PNR message matches the flight criteria&#10;     * @param message The PNR message to check&#10;     * @param targetFlightNumber The target flight number&#10;     * @return true if matches, false otherwise&#10;     */&#10;    private boolean matchesFlightCriteria(PnrMessage message, String targetFlightNumber) {&#10;        if (targetFlightNumber == null || targetFlightNumber.trim().isEmpty()) {&#10;            return true;&#10;        }&#10;        &#10;        // TODO: Implement PNR-specific flight matching logic&#10;        &#10;        return false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/l3/logextractor/test/FXMLTestApp.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/l3/logextractor/test/FXMLTestApp.java" />
              <option name="updatedContent" value="package com.l3.logextractor.test;&#10;&#10;import javafx.application.Application;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Scene;&#10;import javafx.stage.Stage;&#10;&#10;/**&#10; * Simple test application to verify FXML loads correctly&#10; */&#10;public class FXMLTestApp extends Application {&#10;&#10;    @Override&#10;    public void start(Stage primaryStage) {&#10;        try {&#10;            FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;/com/l3/rcaengine/api/log-extraction-view.fxml&quot;));&#10;            Scene scene = new Scene(loader.load(), 1025, 916);&#10;            &#10;            primaryStage.setTitle(&quot;Log Extraction Module - Test&quot;);&#10;            primaryStage.setScene(scene);&#10;            primaryStage.show();&#10;            &#10;            System.out.println(&quot;FXML loaded successfully!&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error loading FXML: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        launch(args);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/l3/logparser/config/AdvancedConfigTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/l3/logparser/config/AdvancedConfigTest.java" />
              <option name="updatedContent" value="package com.l3.logparser.config;&#10;&#10;/**&#10; * Simple test class to verify advanced configuration functionality&#10; */&#10;public class AdvancedConfigTest {&#10;    &#10;    public static void main(String[] args) {&#10;        testAdvancedConfig();&#10;        testApiPatternConfig();&#10;        testConfigPersistence();&#10;    }&#10;    &#10;    private static void testAdvancedConfig() {&#10;        System.out.println(&quot;=== Testing AdvancedParserConfig ===&quot;);&#10;        &#10;        // Create new config&#10;        AdvancedParserConfig config = new AdvancedParserConfig();&#10;        &#10;        // Test default patterns&#10;        ApiPatternConfig apiConfig = config.getApiConfig();&#10;        System.out.println(&quot;Default patterns loaded: &quot; + apiConfig.getMessageStartPatterns().size());&#10;        &#10;        for (ApiPatternConfig.MessagePattern pattern : apiConfig.getMessageStartPatterns()) {&#10;            System.out.println(&quot;Pattern: &quot; + pattern.getName() + &quot; (&quot; + pattern.getType() + &quot;) - &quot; + &#10;                               (pattern.isEnabled() ? &quot;ENABLED&quot; : &quot;DISABLED&quot;));&#10;        }&#10;        &#10;        // Test segment codes&#10;        ApiPatternConfig.SegmentCodes codes = apiConfig.getSegmentCodes();&#10;        System.out.println(&quot;BGM Passenger Code: &quot; + codes.getBgmPassengerCode());&#10;        System.out.println(&quot;LOC Departure Code: &quot; + codes.getLocDepartureCode());&#10;        System.out.println(&quot;DTM Departure Code: &quot; + codes.getDtmDepartureCode());&#10;        System.out.println(&quot;TDT Flight Position: &quot; + codes.getTdtFlightPosition());&#10;    }&#10;    &#10;    private static void testApiPatternConfig() {&#10;        System.out.println(&quot;\n=== Testing ApiPatternConfig ===&quot;);&#10;        &#10;        ApiPatternConfig config = new ApiPatternConfig();&#10;        config.loadDefaults();&#10;        &#10;        // Test adding a new pattern&#10;        ApiPatternConfig.MessagePattern newPattern = &#10;            new ApiPatternConfig.MessagePattern(&quot;TEST_PATTERN&quot;, &quot;contains&quot;, &quot;TEST_VALUE&quot;, true);&#10;        config.getMessageStartPatterns().add(newPattern);&#10;        &#10;        System.out.println(&quot;Added new pattern. Total patterns: &quot; + config.getMessageStartPatterns().size());&#10;        &#10;        // Test modifying segment codes&#10;        config.getSegmentCodes().setBgmPassengerCode(&quot;999&quot;);&#10;        System.out.println(&quot;Modified BGM passenger code: &quot; + config.getSegmentCodes().getBgmPassengerCode());&#10;    }&#10;    &#10;    private static void testConfigPersistence() {&#10;        System.out.println(&quot;\n=== Testing Configuration Persistence ===&quot;);&#10;        &#10;        try {&#10;            // Create and modify config&#10;            AdvancedParserConfig config = new AdvancedParserConfig();&#10;            config.getApiConfig().getSegmentCodes().setBgmPassengerCode(&quot;777&quot;);&#10;            &#10;            // Save to file&#10;            boolean saveSuccess = config.saveToFile();&#10;            System.out.println(&quot;Save to file: &quot; + (saveSuccess ? &quot;SUCCESS&quot; : &quot;FAILED&quot;));&#10;            &#10;            // Load new instance&#10;            AdvancedParserConfig loadedConfig = new AdvancedParserConfig();&#10;            String loadedCode = loadedConfig.getApiConfig().getSegmentCodes().getBgmPassengerCode();&#10;            System.out.println(&quot;Loaded BGM passenger code: &quot; + loadedCode);&#10;            &#10;            // Check if persistence worked&#10;            System.out.println(&quot;Persistence test: &quot; + (&quot;777&quot;.equals(loadedCode) ? &quot;SUCCESS&quot; : &quot;FAILED&quot;));&#10;            &#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Persistence test FAILED: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>